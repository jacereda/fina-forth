#args( -- n ) Get the number of command line arguments
#bits/byte( -- n ) Number of bits in a byte
#bits/cell( -- n ) Number of bits in a cell
#bits/char( -- n ) Number of bits in a char
+"( "ccc<quote>" -- ) Parse ccc delimited by double quote and place the string as counted string in the stringtable
+field( structure-sys n "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of size n bytes, return the field address
,\"( "ccc<quote>" -- ) Store a string with escaped characters in the dictionary
0!( a-addr -- ) Set address to zero
0e+0( F: -- r ) Float constant 0.0
1+!( a-addr -- ) Increase contents of address by 1
1-!( a-addr -- ) Decrease contents of address by 1
1e+0( F: -- r ) Float constant 1.0
2e+0( F: -- r ) Float constant 2.0
<=>( n1 n2 -- n ) Compare the two numbers and return the compare result [-1,0,1]
<l@( l-addr -- n ) Fetch a long word, 32 bit, sign extend
<l@( l-addr -- n ) Fetch a long word, 32 bit, sign extend
<w@( w-addr -- n ) Fetch a word, 16 bit, sign extend
<w@( w-addr -- n ) Fetch a word, 16 bit, sign extend
>enum:( enum-sys n "<spaces>name" -- enum-sys ; -- n ) Define an enumeration starting with n, return the enum value
?0( x -- ) Check for zero value on stack
?d( d1 d2 -- ) Check for a signed double on stack
?false( flag -- ) Check for false value on stack
?free( addr -- ior ) Free the address if not nil
?nil( addr -- ) Check for nil value on stack
?r( r1 r2 -- ) Check for float value on stack
?s( n1 n2 -- ) Check for signed value on stack
?str( c-addr1 u1 c-addr2 u2 -- ) Check for a string on the stack
?true( flag -- ) Check for true value on stack
?u( u1 u2 -- ) Check for unsigned value on stack
?ud( ud1 ud2 -- ) Check for an unsigned double on stack
@!( x1 a-addr -- x2 ) First fetch the contents x2 and then store value x1
a32%( -- n ) Get the required space for an Adler32 variable
a32+to-string( u -- c-addr u ) Convert the Adler32 result to a string, using the pictured output area
a32-create( "<spaces>name" -- ; -- a32 ) Create a named Adler32 variable in the dictionary
a32-dump( a32 -- ) Dump the Adler32 variable
a32-finish( a32 -- u ) Finish the Adler32 calculation, return the result u
a32-free( a32 -- ) Free the Adler32 variable from the heap
a32-init( a32 -- ) Initialise the Adler32 variable
a32-length@( a32 -- u ) Get the length of the sum
a32-new( -- a32 ) Create a new Adler32 variable on the heap
a32-reset( a32 -- ) Reset the Adler32 state
a32-update( c-addr u a32 -- ) Update the Adler32 with more data c-addr u
a32^combine( a32 a32 -- u ) Combine the twee Addler32 sums and return the combined sum u
acn%( -- n ) Get the required space for an acn node
acn-dump( acn -- ) Dump the node
acn-free( acn -- ) Free the node from the heap
acn-init( x1 x2 acn1 acn2 -- ) Initialise the node acn2 with the parent acn1, key x2 and data x1
acn-new( x1 x2 acn1 -- acn2 ) Create a new node acn2 on the heap with parent acn1, key x2 and data x1
act%( -- n ) Get the required space for an act variable
act-(free)( act -- ) Free the nodes from the heap
act-clear( act -- ) Delete all nodes in the tree
act-compare!( xt act -- ) Set the compare execution token for comparing keys
act-compare@( act -- xt ) Get the compare execution token for comparing keys
act-create( "<spaces>name" -- ; -- act ) Create a named tree in the dictionary
act-delete( x1 act -- false | x2 true ) Delete key x1 from the tree, return the data x2 if found
act-dump( act -- ) Dump the tree variable
act-empty?( act -- flag ) Check for an empty tree
act-execute( i*x xt act -- i*x ) Execute xt for every key and data in the tree
act-execute?( i*x xt bct -- j*x flag ) Execute xt for every key and data in the tree until xt returns true
act-free( act -- ) Free the tree from the heap
act-get( x1 act -- false | x2 true ) Get the data x2 related to key x1 from the tree
act-has?( x1 act -- flag ) Check if the key x1 is present in the tree
act-init( act -- ) Initialise the act tree
act-insert( x1 x2 act -- ) Insert data x1 with key x2 in the tree
act-length@( act -- u ) Get the number of elements in the tree
act-new( -- act ) Create a new tree on the heap
arg%( -- n ) Get the required space for an argument parser variable
arg-(free)( arg -- ) Free the internal, private variables from the heap
arg-add-help-option( arg -- ) Add the default help option
arg-add-option( char c-addr1 u1 c-addr2 u2 flag n arg -- ) Add an option to the parser with the short option char, the long option c-addr1 u1, the description c-addr2 u2, the switch flag and the identifier n [id=4..]
arg-add-version-option( arg -- ) Add the default version option
arg-create( c-addr1 u1 c-addr2 u2 c-addr3 u3 c-addr4 u4 "<spaces>name" -- ; -- arg ) Create a named parser in the dictionary with the program name c-addr1 u1, the usage c-addr2 u2, the version c-addr3 u3 and general info c-addr4 u4
arg-free( arg -- ) Free the parser from the heap
arg-init( c-addr1 u1 c-addr2 u2 c-addr3 u3 c-addr4 u4 arg -- ) Initialise the parser with the program name c-addr1 u1, the usage c-addr2 u2, the version c-addr3 u3 and general info c-addr4 u4
arg-new( c-addr1 u1  c-addr2 u2 c-addr3 u3 c-addr4 u4 -- arg ) Create a new parser on the heap with the program name c-addr1 u1, the usage c-addr2 u2, the version c-addr3 u3 and general info c-addr4 u4
arg-parse( arg -- c-addr u n | n ) Parse the next command line argument, return the option identifier and optional the parameter
arg-print-help( arg -- ) Print the help info
arg-print-version( arg -- ) Print the version info
arg.cols( -- n ) Value with the number of columns for parser output [def. 79]
arg.done( -- n ) Done parsing
arg.error( -- n ) Error in option
arg.help-option( -- n ) Help option
arg.non-option( -- n ) Non option
arg.version-option( -- n ) Version option
arg@( n -- c-addr u ) Get the nth command line argument
b64-decode( c-addr1 u1 str -- c-addr2 u2 ) Decode the string c-addr1 u1 using str, resulting in c-addr2 u2 in str, throws exp-invalid-data for characters out of range
b64-encode( c-addr1 u1 str -- c-addr2 u2 ) Encode the string c-addr u with str, resulting in c-addr2 u2 in str
bar%( -- n ) Get the required space for a bar variable
bar-(free)( bar -- ) Free the internal data from the heap
bar-count( bar -- u ) Count the number of bits set in the array
bar-count-bits( +n1 n2 bar -- u ) Count the number of bits set in a range in the array, starting from the n2th bit, n1 bits long
bar-create( +n "<spaces>name" -- ; -- bar ) Create a bit array in the dictionary with length n
bar-dump( bar -- ) Dump the bit array
bar-execute( i*x xt bar -- j*x ) Execute xt for every bit in the array
bar-free( bar -- ) Free the array from the heap
bar-get-bit( n bar -- flag ) Check if the nth bit is set
bar-index?( n bar -- flag ) Check if the index n is valid in the array
bar-init( +n bar -- ) Initialise the array with length n
bar-invert( bar -- ) Invert all bits in the array
bar-invert-bit( n bar -- ) Invert the nth bit
bar-invert-bits( u n bar -- ) Invert a range of bits in the array, starting from the nth bit, u bits long
bar-length@( bar -- +n ) Get the number of bits in the array
bar-new( n -- bar ) Create a bit array on the heap with length n
bar-reset( bar -- ) Reset all bits in the array
bar-reset-bit( n bar -- ) Reset the nth bit
bar-reset-bits( u n bar -- ) Reset a range of bits in the array, starting from the nth bit, u bits long
bar-reset-list( nu .. n1 u bar -- ) Reset n1 till nuth bits in the array
bar-set( bar -- ) Set all bits in the array
bar-set-bit( n bar -- ) Set the nth bit in the array
bar-set-bits( u n bar -- ) Set a range of bits in the array, starting from the nth bit, u bits long
bar-set-list( nu .. n1 u bar -- ) Set n1 till nuth bits in the array
bar^and( bar1 bar2 -- ) AND the bit arrays bar1 and bar2 and store the result in bar2
bar^move( bar1 bar2 -- ) Move bar1 into bar2
bar^or( bar1 bar2 -- ) OR the bit arrays bar1 and bar2 and store the result in bar2
bar^xor( bar1 bar2 -- ) XOR the bit arrays bar1 and bar2 and store the result in bar2
bci%( -- n ) Get the required space for a bci variable
bci-create( bct "<spaces>name" -- ; -- bci ) Create a named iterator in the dictionary with a binary tree
bci-dump( bci -- ) Dump the iterator variable
bci-first( bci -- x true | false ) Move the iterator to the first node, return the cell data x
bci-first?( bci -- flag ) Check if the iterator is on the first node
bci-free( bci -- ) Free the iterator from the heap
bci-get( bci -- false | x true ) Get the cell data x from the current node
bci-init( bct bci -- ) Initialise the iterator with a binary tree
bci-key( bci -- false | x true ) Get the key x from the current node
bci-last( bci -- x true | false ) Move the iterator to the last node, return the cell data x
bci-last?( bci -- flag ) Check if the iterator is on the last node
bci-move( x bci -- flag ) Move the iterator to the next node with the cell data x
bci-new( bct -- bci ) Create an iterator on the heap with a binary tree
bci-next( bci -- x true | false ) Move the iterator to the next node, return the cell data x
bci-prev( bci -- x true | false ) Move the iterator to the previous node, return the cell data x
bci-set( x bci -- ) Set the cell data x for the current node
bcn%( -- n ) Get the required space for a bcn node
bcn-cell!( bcn1 -- bcn2 ) Get the right node from the node bcn1
bcn-cell@( bcn1 -- bcn2 ) Get the left node from the node bcn1
bcn-dump( bcn -- ) Dump the node
bcn-free( bcn -- ) Free the node from the heap
bcn-init( x1 x2 bcn1 bcn2 -- ) Initialise the node bcn2 with the parent bcn1, key x2 and data x1
bcn-new( x1 x2 bcn1 -- bcn2 ) Create a new node on the heap with the parent bcn1, key x2 and data x1
bct%( -- n ) Get the required space for a bct variable
bct-(free)( bct -- ) Free the nodes from the heap
bct-clear( bct -- ) Delete all nodes in the tree
bct-compare!( xt bct -- ) Set the compare execution token for comparing keys
bct-compare@( bct -- xt ) Get the compare execution token for comparing keys
bct-create( "<spaces>name" -- ; -- bct ) Create a named binary tree in the dictionary
bct-delete( x1 bct -- false | x2 true ) Delete key x1 from the tree, return the cell data x2
bct-dump( bct -- ) Dump the tree node structure
bct-empty?( bct -- flag ) Check for an empty tree
bct-execute( i*x xt bct -- j*x ) Execute xt for every key and data in the tree
bct-execute?( i*x xt bct -- j*x flag ) Execute xt for every key and data in the tree until xt returns true
bct-free( bct -- ) Free the tree node from the heap
bct-get( x1 bct -- false | x2 true ) Get the data x2 related to key x1 from the tree
bct-has?( x1 bct -- flag ) Check if the key x1 is present in the tree
bct-init( bct -- ) Initialise the tree
bct-insert( x1 x2 bct -- ) Insert data x1 with key x2 in the tree
bct-length@( bct -- u ) Get the number of elements in the tree
bct-new( -- bct ) Create a new binary tree on the heap
begin-enumeration( -- enum-sys ) Start an enumeration definition, the first enumeration will start from 0
begin-stringtable( "<spaces>name" -- stringtable-sys ; n -- c-addr u ) Start a named stringtable definition; return the nth string
begin-structure( "<spaces>name" -- structure-sys ; -- n ) Start definition of a named structure, return the structure size
bigendian?( -- flag ) Check for bigendian hardware
bis%( -- n ) Get the required space for a bis variable
bis-bits>bytes( bis -- ) Start reading bytes, dropping the not-byte-aligned bits
bis-bytes>bits( bis -- ) Start reading bits from the stream
bis-create( "<spaces>name" -- ; -- bis ) Create a named bit input stream variable in the dictionary
bis-dump( bis -- ) Dump the bit input stream
bis-fetch-bits( u1 bis -- u2 ) Fetch u1 bits from the buffer and return the value
bis-free( bis -- ) Free the bit input stream variable from the heap
bis-get( bis -- c-addr u ) Get the data string from the input stream
bis-get-bit( bis -- false | u true ) Get a single bit u from the buffer
bis-init( bis -- ) Initialise the bit input stream variable
bis-need-bits( n bis -- flag ) Check if there are n bits from the stream available in the buffer
bis-new( -- bis ) Create a new bit input stream variable on the heap
bis-next-bits( n bis -- ) Set n bits processed in the buffer
bis-read-bytes( n1 bis -- false | n2 true ) Try reading n1 bytes via the buffer from the stream, return the read number, n1 <= #bytes/cell
bis-reset( bis -- ) Reset the input buffer, not the input stream
bis-set( c-addr u bis -- ) Set the data string for the input stream
bni%( -- n ) Get the required space for a bni variable
bni-create( bnt "<spaces>name" -- ; -- bni ) Create a named iterator in the dictionary with a binary tree
bni-dump( bni -- ) Dump the iterator variable
bni-first( bni -- bnn | nil ) Move the iterator to the first node, return this node
bni-first?( bni -- flag ) Check if the iterator is on the first node
bni-free( bni -- ) Free the iterator from the heap
bni-get( bni -- bnn | nil ) Get the current node from the iterator
bni-init( bnt bni -- ) Initialise the iterator with a binary tree
bni-key( bni -- false | x true ) Get the key x from the current node
bni-last( bni -- bnn | nil ) Move the iterator to the last node, return this node
bni-last?( bni -- flag ) Check if the iterator is on the last node
bni-new( bnt -- bni ) Create an iterator on the heap with a binary tree
bni-next( bni -- bnn | nil ) Move the iterator to the next node, return this node
bni-prev( bni -- bnn | nil ) Move the iterator to the previous node, return this node
bnn%( -- n ) Get the required space for a bnn node
bnn-dump( bnn -- ) Dump the node
bnn-free( bnn -- ) Free the node from the heap
bnn-init( x bnn1 bnn2 -- ) Initialise the node bnn2 with parent bnn1 and key x
bnn-key@( bnn -- x ) Get the key from the node
bnn-new( x bnn1 -- bnn2 ) Create a new node on the heap with parent bnn1 and key x
bnt%( -- n ) Get the required space for a bnt variable
bnt-(free)( xt bnt -- ) Free the nodes from the heap using xt
bnt-clear( xt bnt -- ) Delete all nodes in the tree using word xt
bnt-compare!( xt bnt -- ) Set the compare execution token for comparing keys
bnt-compare@( bnt -- xt ) Get the compare execution token for comparing keys
bnt-create( "<spaces>name" -- ; -- bnt ) Create a named binary tree in the dictionary
bnt-delete( x bnt -- false | bnn true ) Delete key x from the tree, return the deleted node
bnt-dump( bnt -- ) Dump the tree node structure
bnt-empty?( bnt -- flag ) Check for an empty tree
bnt-execute( i*x xt bnt -- j*x ) Execute xt for every node in the tree
bnt-execute?( i*x xt bnt -- j*x flag ) Execute xt for every node in the tree until xt returns true
bnt-free( bnt -- ) Free the tree node from the heap
bnt-get( x bnt -- false | bnn true ) Get the node related to key x from the tree
bnt-has?( x1 bnt -- flag ) Check if the key x1 is present in the tree
bnt-init( bnt -- ) Initialise the tree
bnt-insert( i*x xt x bct -- bnn1 true | i*x bnn2 false ) Insert a new unique node in the tree with key x, creation word xt and optional parameters
bnt-length@( bnt -- u ) Get the number of elements in the tree
bnt-new( -- bnt ) Create a new binary tree on the heap
car%( -- n ) Get the required space for a car variable
car+extra!( u -- ) Set the initial extra space allocated during resizing of the array
car+extra@( -- u ) Get the initial extra space allocated during resizing of the array
car-(free)( car -- ) Free the internal data from the heap
car-append( x car -- ) Append the cell value at the end of the array
car-clear( car -- ) Clear the array
car-compare!( xt car -- ) Set the compare execution token for sorting the array
car-compare@( car -- xt ) Get the compare execution token for sorting the array
car-count( x car -- u ) Count the number of occurrences of a cell value x in the array
car-create( n "<spaces>name" -- ; -- car ) Create a cell array in the dictionary with an initial length n
car-delete( n car -- x ) Delete the cell value at the nth position, return the previous cell value x
car-dequeue( car -- x ) Dequeue the cell value from the end of the array, exception if array is empty
car-dump( car -- ) Dump the cell array variable
car-enqueue( x car -- ) Enqueue the cell value x at the start of the array
car-execute( i*x xt car -- j*x ) Execute the execution token for every cell in the array
car-extra!( u car -- ) Set the extra space allocated during resizing of the array
car-extra@( car -- u ) Get the extra space allocated during resizing of the array
car-find( x car -- n ) Find the offset first occurrence of the cell value x in the array, -1 if not found
car-find-sorted( x car -- n flag ) Find the cell value x in the already sorted array using binary search, return offset and success
car-free( car -- ) Free the array from the heap
car-get( n car -- x ) Get the cell value from the nth element
car-has-sorted?( x car -- flag ) Check if the cell value x is present in an already sorted array
car-has?( x car -- flag ) Check if a cell value x is present in the array
car-index?( n car -- flag ) Check if the index n is valid in the array
car-init( +n car -- ) Initialise the array with an initial length n
car-insert( x n car -- ) Insert the cell value x at the nth element
car-insert-sorted( x car -- ) Insert the cell value x sorted in an already sorted array
car-length@( car -- u ) Get the number of elements in the array
car-new( n -- car ) Create a cell array with an initial length n on the heap
car-pop( car -- x ) Pop the cell value from the end of the array, exception if array is empty
car-prepend( x car -- ) Prepend the cell value at the start of the array
car-push( x car -- ) Push the cell value x at the end of the array
car-set( x n car -- ) Set the cell value x at the nth element
car-size!( +n car -- ) Insure the size of the array
car-sort( car -- ) Sort the array using the compare execution token using heap sort
car-tos( car -- x ) Get the cell value at the end of the array, exception if array is empty
cbf%( -- n ) Get the required space for a cbf variable
cbf+extra!( u -- ) Set the initial number of extra elements allocated during resizing of the buffer
cbf+extra@( -- u ) Get the initial number of extra elements allocated during resizing of the buffer
cbf-(free)( cbf -- ) Free the internal data from the heap
cbf-access!( xt1 xt2 cbf -- ) Set the store word xt1 and the fetch word x2 for the buffer
cbf-access@( cbf -- xt1 xt2 ) Get the store word xt1 and the fetch word xt2 for the buffer
cbf-clear( cbf -- ) Clear the buffer
cbf-create( +n1 +n2 "<spaces>name" -- ; -- cbf ) Create a circular buffer in the dictionary with element size n1 and initial length n2
cbf-dequeue( cbf -- i*x | addr true | false ) Dequeue one element from the buffer, optional using the fetch word
cbf-dump( cbf -- ) Dump the circular buffer variable
cbf-enqueue( i*x | addr cbf -- ) Enqueue one element in the buffer, optional using the store word
cbf-extra!( u cbf -- ) Set the number of extra elements allocated during resizing of the buffer
cbf-extra@( cbf -- u ) Get the number of extra elements allocated during resizing of the buffer
cbf-fetch( addr u1 cbf -- u2 ) Fetch maximum u1 elements from the buffer in addr, return the actual number of elements u2
cbf-free( cbf -- ) Free the circular buffer from the heap
cbf-get( addr u1 cbf -- u2 ) Get maximum u1 elements from the buffer in addr, return the actual number of elements u2
cbf-init( +n1 +n2 cbf -- ) Initialise the buffer with element size n1 and initial length n2
cbf-length@( cbf -- u ) Get the number of elements in the buffer
cbf-new( +n1 +n2 -- cbf ) Create a circular buffer with element size n1 and initial length n2 on the heap
cbf-pop( cbf -- i*x | addr true | false ) Pop one element from the buffer, optional using the fetch word
cbf-push( i*x | addr cbf -- ) Push one element in the buffer, optional using the store word
cbf-set( addr u cbf -- ) Set u elements, starting from addr in the buffer, resize if necessary
cbf-size!( +n cbf -- ) Insure the size of the buffer
cbf-skip( +n1 cbf -- +n2 ) Skip maximum u1 elements from the buffer, return the actual skipped elements u2
cbf-tos( cbf -- i*x | addr true | false ) Fetch the top element, optional using the fetch word
cfield:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of 1 char, return the field address
cfields:( structure-sys n "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of n chars, return the field address
chr-alnum?( char -- flag ) Check for an alphanumeric character
chr-alpha?( char -- flag ) Check for an alphabetic character
chr-ascii?( char -- flag ) Check for an ascii character
chr-base( char -- false | u true ) Convert the character to a digit according the current base
chr-blank?( char -- flag ) Check for a blank character, space or tab
chr-cntrl?( char -- flag ) Check for a control character, 0 till 31
chr-digit?( char -- flag ) Check for a decimal digit character
chr-graph?( char -- flag ) Check for a printable character except space
chr-hexdigit?( char -- flag ) Check for a hexadecimal character
chr-lower( char1 -- char2 ) Convert char1 to lowercase
chr-lower?( char -- flag ) Check for a lowercase alphabetic character
chr-octdigit?( char -- flag ) Check for an octal character
chr-print?( char -- flag ) Check for a printable character including space
chr-punct?( char -- flag ) Check for a printable character, but not a space or alphanumeric character
chr-range?( char1 char2 char3 -- flag ) Check if char1 is in the range [char2..char3]
chr-space?( char -- flag ) Check for a white-space: space, lf, vt, ff, cr
chr-string?( c-addr u char -- flag ) Check if the character is in the string
chr-upper( char1 -- char2 ) Convert char1 to uppercase
chr-upper?( char -- flag ) Check for an uppercase alphabetic character
chr.ack( -- char ) the ack character
chr.bel( -- char ) the bel character
chr.bs( -- char ) the backspace character
chr.can( -- char ) the cancel character
chr.cr( -- char ) the carriage return character
chr.dc1( -- char ) the dc1 character
chr.dc2( -- char ) the dc2 character
chr.dc3( -- char ) the dc3 character
chr.dc4( -- char ) the dc4 character
chr.del( -- char ) the delete character
chr.dle( -- char ) the dle character
chr.em( -- char ) the em character
chr.enq( -- char ) the enq character
chr.eot( -- char ) the eot character
chr.esc( -- char ) the escape character
chr.etb( -- char ) the etc character
chr.etx( -- char ) the etx character
chr.ff( -- char ) the formfeed character
chr.fs( -- char ) the fs character
chr.gs( -- char ) the gs character
chr.ht( -- char ) the horz. tab character
chr.lf( -- char ) the line feed character
chr.nak( -- char ) the nak character
chr.nul( -- char ) the null character
chr.rs( -- char ) the rs character
chr.si( -- char ) the si character
chr.sm( -- char ) the sm character
chr.soh( -- char ) the soh character
chr.sp( -- char ) the space character
chr.stx( -- char ) the stx character
chr.sub( -- char ) the sub character
chr.syn( -- char ) the syn character
chr.us( -- char ) the us character
chr.vt( -- char ) the vert. tab character
chs%( -- n ) Get the required space for a chs variable
chs-char?( char chs -- flag ) Check if the character is in the set
chs-create( "<spaces>name" -- ; -- chs ) Create a named character set in the dictionary
chs-dump( chs -- ) Dump the chs state
chs-execute( i*x xt chs -- j*x ) Execute xt for every character in the set
chs-free( chs -- ) Free the set from the heap
chs-init( chs -- ) Initialise the set
chs-invert( chs -- ) Invert all characters in the set
chs-new( -- chs ) Create a new character set on the heap
chs-reset( chs -- ) Reset all characters in the set
chs-reset-alnum( chs -- ) Reset the alnum class in the set
chs-reset-alpha( chs -- ) Reset the alpha class in the set
chs-reset-blank( chs -- ) Reset the blank class in the set
chs-reset-char( char chs -- ) Reset the character in the set
chs-reset-chars( char1 char2 chs -- ) Reset the character range [char2..char1] in the set
chs-reset-cntrl( chs -- ) Reset the cntrl class in the set
chs-reset-digit( chs -- ) Reset the digit class in the set
chs-reset-graph( chs -- ) Reset the graph class in the set
chs-reset-list( charu .. char1 u chs -- ) Reset the characters char1 till charu in the set
chs-reset-lower( chs -- ) Reset the lower class in the set
chs-reset-print( chs -- ) Reset the print class in the set
chs-reset-punct( chs -- ) Reset the punct class in the set
chs-reset-space( chs -- ) Reset the space class in the set
chs-reset-string( c-addr u chs -- ) Reset the characters in the string in the set
chs-reset-upper( chs -- ) Reset the upper class in the set
chs-reset-word( chs -- ) Reset the word class in the set
chs-reset-xdigit( chs -- ) Reset the xdigit class in the set
chs-set( chs -- ) Set all characters in the set
chs-set-alnum( chs -- ) Set the alnum class in the set
chs-set-alpha( chs -- ) Set the alpha class in the set
chs-set-blank( chs -- ) Set the blank class in the set
chs-set-char( char chs -- ) Set the character in the set
chs-set-chars( char1 char2 chs -- ) Set the character range [char2..char1] in the set
chs-set-cntrl( chs -- ) Set the cntrl class in the set
chs-set-digit( chs -- ) Set the digit class in the set
chs-set-graph( chs -- ) Set the graph class in the set
chs-set-list( charu .. char1 u chs -- ) Set the characters char1 till charu in the set
chs-set-lower( chs -- ) Set the lower  class in the set
chs-set-print( chs -- ) Set the print class in the set
chs-set-punct( chs -- ) Set the punct class in the set
chs-set-space( chs -- ) Set the space class in the set
chs-set-string( c-addr u chs -- ) Set the characters in the string in the set
chs-set-upper( chs -- ) Set the upper class in the set
chs-set-word( chs -- ) Set the word class in the set
chs-set-xdigit( chs -- ) Set the xdigit class in the set
chs^and( chs1 chs2 -- ) AND the sets chs1 with chs2 and store the result in chs2
chs^move( chs1 chs2 -- ) Move chs1 in chs2
chs^or( chs1 chs2 -- ) OR the sets chs1 with chs2 and store the result in chs2
chs^xor( chs1 chs2 -- ) XOR the sets chs1 with chs2 and store the result in chs2
cpx%( -- n ) Get the required space for a cpx variable
cpx+abs( F: r1 r2 -- r3 ) Calculate the modulus of the complex number r1+jr2
cpx+acos( F: r1 r2 -- r3 r4 ) Calculate the inverse trigonometric function cosine for the complex number r1+jr2
cpx+acosh( F: r1 r2 -- r3 r4 ) Calculate the inverse hyperbolic function cosine for the complex number r1+jr2
cpx+add( F: r1 r2 r3 r4 -- r5 r6 ) Add the complex number r1+jr2 to r3+jr4
cpx+asin( F: r1 r2 -- r3 r4 ) Calculate the inverse trigonometric function sine for the complex number r1+jr2
cpx+asinh( F: r1 r2 -- r3 r4 ) Calculate the inverse hyperbolic function sine for the complex number r1+jr2
cpx+atan( F: r1 r2 -- r3 r4 ) Calculate the inverse trigonometric function tangent for the complex number r1+jr2
cpx+atanh( F: r1 r2 -- r3 r4 ) Calculate the inverse hyperbolic function tangent for the complex number r1+jr2
cpx+conj( F: r1 r2 -- r3 r4 ) Conjugate the complex number r1+jr2
cpx+cos( F: r1 r2 -- r3 r4 ) Calculate the trigonometric functions cosine for the complex number r1+jr2
cpx+cosh( F: r1 r2 -- r3 r4 ) Calculate the hyperbolic function cosine for the complex number r1+jr2
cpx+div( F: r1 r2 r3 r4 -- r5 r6 ) Divide the complex number r3+jr4 by number r1+jr2
cpx+equal?( F: r1 r2 r3 r4 -- ; -- flag ) Check if the complex numbers r1+jr2 and r3+jr4 are [true] equal
cpx+exp( F: r1 r2 -- r3 r4 ) Calculate the exponent function for the complex number r1+jr2
cpx+from-polar( F: r1 r2 -- r3 r4 ) Convert the polar radius r1, theta r2 to complex number r3+jr4
cpx+imul( F: r1 r2 r3 -- r4 r5 ) Multiply the complex number r1+jr2 with the imaginary number r3
cpx+ln( F: r1 r2 -- r3 r4 ) Calculate the natural logarithm for the complex number r1+jr2
cpx+mul( F: r1 r2 r3 r4 -- r5 r6 ) Multiply the complex numbers r1+jr2 with r3+jr4
cpx+nrm( F: r1 r2 -- r3 ) Calculate the square of the modulus of the complex number r1+jr2
cpx+rmul( F: r1 r2 r3 -- r4 r5 ) Multiply the complex number r1+jr2 with the real number r3
cpx+sin( F: r1 r2 -- r3 r4 ) Calculate the trigonometric functions sine for the complex number r1+jr2
cpx+sinh( F: r1 r2 -- r3 r4 ) Calculate the hyperbolic function sine for the complex number r1+jr2
cpx+sqrt( F: r1 r2 -- r3 r4 ) Calculate the square root for the complex number r1+jr2
cpx+sub( F: r1 r2 r3 r4 -- r5 r6 ) Subtract the complex number r1+jr2 from the number r3+jr4
cpx+tan( F: r1 r2 -- r3 r4 ) Calculate the trigonometric functions tangent for the complex number r1+jr2
cpx+tanh( F: r1 r2 -- r3 r4 ) Calculate the hyperbolic function tangent for the complex number r1+jr2
cpx+to-polar( F: r1 r2 -- r3 r4 ) Convert the complex number r1+jr2 to polar notation with radius r3 and theta r4
cpx+to-string( F: r1 r2 -- ; -- c-addr u ) Convert the complex number r1+jr2 to a string, using precision and PAD
cpx-create( "<spaces>name" -- ; -- cpx ) Create a named complex number variable in the dictionary
cpx-dump( cpx -- ) Dump the complex variable
cpx-free( cpx -- ) Free the complex number variable from the heap
cpx-get( F: -- r1 r2 ; cpx -- ) Get the complex number r1+jr2 from the complex variable
cpx-im@( F: -- r ; cpx -- ) Get the imaginary part of the complex number
cpx-init( cpx -- ) Initialise to the zero complex number
cpx-new( -- cpx ) Create a new complex number variable on the heap
cpx-re@( F: -- r ; cpx -- ) Get the real part of the complex number
cpx-set( F: r1 r2 -- ; cpx -- ) Set the complex number r1+jr2 in the complex variable
cpx^equal?( cpx2 cpx1 -- flag ) Check if complex2 is [true] equal to complex1
cpx^move( cpx2 cpx1 -- ) Move complex2 in complex1
crc%( -- n ) Get the required space for a crc-32 variable
crc+calc-crc32( c-addr u -- u1 ) Calculate the CRC32 for byte data with default crc32 table
crc+calc-poly( u1 .. un n -- u ) Calculate the polynomial u
crc-(free)( crc -- ) Free the internal table from the heap
crc-create( "<spaces>name" -- ; -- crc ) Create a named crc variable in the dictionary
crc-finish( crc -- u ) Finish the calculation, return the CRC32 result
crc-free( crc -- ) Free the crc from the heap
crc-init( crc -- ) Initialise the crc
crc-new( -- crc ) Create a new crc variable on the heap
crc-poly!( u crc -- ) Use the polynomial u for the crc
crc-poly@( crc -- u ) Get the polynomial u in the crc
crc-reset( crc -- ) Reset the crc calculation
crc-update( c-addr u crc -- ) Update the crc structure with more byte data
dci%( -- n ) Get the required space for a dci variable
dci-create( dcl "<spaces>name" -- ; -- dci ) Create a named iterator in the dictionary with a dcl list
dci-dump( dci -- ) Dump the iterator
dci-first( dci -- x true | false ) Move the iterator to the first record, return the cell data x
dci-first?( dci -- flag ) Check if the iterator is on the first record
dci-free( dci -- ) Free the iterator from the heap
dci-get( dci -- x true | false ) Get the cell data x from the current record
dci-init( dcl dci -- ) Initialise the iterator with a dcl list
dci-insert-after( x dci -- ) Insert the cell data x after the current record
dci-last( dci -- x true | false ) Move the iterator to the last record, return the cell data x
dci-last?( dci -- flag ) Check if the iterator is on the last record
dci-move( x dci -- false ) Move the iterator to the next record with the cell data x
dci-new( dcl -- dci ) Create an iterator on the heap with a dcl list
dci-next( dci -- x true | false ) Move the iterator to the next record, return the cell data x
dci-prev( dci -- x true | false ) Move the iterator to the previous record, return the cell data x
dci-set( x dci -- ) Set the cell data x for the current record
dcl%( -- n ) Get the required space for a dcl variable
dcl-(free)( dnl -- ) Free the nodes from the heap
dcl-append( x dcl -- ) Append the cell data x in the list
dcl-clear( dnl -- ) Delete all nodes from the list
dcl-compare!( xt dcl -- ) Set the compare execution token for sorting the list
dcl-compare@( dcl -- xt ) Get the compare execution token for sorting the list
dcl-count( x dcl -- u ) Count the number of occurrences of the cell data x in the list
dcl-create( "<spaces>name" -- ; -- dcl ) Create a named dcl list in the dictionary
dcl-delete( n dcl -- x ) Delete the nth node from the list, return the cell data x
dcl-dump( dcl -- ) Dump the list
dcl-empty?( dcl -- flag ) Check for empty list
dcl-execute( i*x xt dcl -- j*x ) Execute xt for every cell data in list
dcl-find( x dcl -- n ) Find the first index for the cell data x in the list, -1 for not found
dcl-free( dcl -- ) Free the list from the heap, including the nodes
dcl-get( n dcl -- x ) Get the cell data x from the nth node from the list
dcl-has?( x dcl -- flag ) Check if the cell data x is present in the list
dcl-index?( n dcl -- flag ) Check if the index n is valid for the list
dcl-init( dcl -- ) Initialise the dcl list
dcl-insert( x n dcl -- ) Insert cell data x at the nth node in the list
dcl-insert-sorted( x dcl -- ) Insert the cell data x sorted in the list
dcl-length@( dcl -- u ) Get the number of nodes in the list
dcl-new( -- dcl ) Create a new dcl list on the heap
dcl-prepend( x dcl -- ) Prepend the cell data x in the list
dcl-remove( x dcl -- flag ) Remove the first occurrence of the cell data x from the list, return success
dcl-reverse( dcl -- ) Reverse or mirror the list
dcl-set( x n dcl -- ) Set the cell data x in the nth node in the list
dcn%( -- n ) Get the required space for a dcn node
dcn-cell!( x dcn -- ) Set the cell data x in the node
dcn-cell@( dcn -- x ) Get the cell data x from the node
dcn-dump( dcn -- ) Dump the node
dcn-free( dcn -- ) Free the node from the heap
dcn-init( x dcn -- ) Initialise the node with data x
dcn-new( x -- dcn ) Create a new node on the heap with data x
debug"( "ccc<quote>" -- ) Log a debug message
dffield:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of 1 double float, return the field address
dfield:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of 1 double, return the field address
dfields:( structure-sys n "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of n doubles, return the field address
dni%( -- n ) Get the required space for a dni variable
dni-create( dnl "<spaces>name" -- ; -- dni ) Create a named iterator in the dictionary with a dnl list
dni-dump( dni -- ) Dump the iterator variable
dni-first( dni -- dnn | nil ) Move the iterator to the first node, return this node
dni-first?( dni -- flag ) Check if the iterator is on the first node
dni-free( dni -- ) Free the iterator from the heap
dni-get( dni -- dnn | nil ) Get the current node
dni-init( dnl dni -- ) Initialise the iterator with a dnl list
dni-last( dni -- dnn | nil ) Move the iterator to the last node, return this node
dni-last?( dni -- flag ) Check if the iterator is on the last node
dni-new( dnl -- dni ) Create an iterator on the heap
dni-next( dni -- dnn | nil ) Move the iterator to the next node, return this node
dni-prev( dni -- dnn | nil ) Move the iterator to the previous node, return this node
dnl%( -- n ) Get the required space for a dnl variable
dnl-(free)( xt dnl -- ) Free the nodes in the list from the heap using xt
dnl-append( dnn dnl -- ) Append the node dnn in the list
dnl-create( "<spaces>name" -- ; -- dnl ) Create a named dnl list in the dictionary
dnl-delete( n dnl -- dnn ) Delete the nth node from the list, return the deleted node
dnl-dequeue( dnl -- dnn | nil ) Dequeue the node dnn from the end of the list
dnl-dump( dnl -- ) Dump the list
dnl-empty?( dnl -- flag ) Check for empty list
dnl-enqueue( dnn dnl -- ) Enqueue the node dnn at the start of the list
dnl-execute( i*x xt dnl -- j*x ) Execute xt for every node in list
dnl-first@( dnl -- dnn | nil ) Get the first node in the list
dnl-free( dnl -- ) Free the list from the heap
dnl-get( n dnl -- dnn ) Get the nth node from the list
dnl-index?( n dnl -- flag ) Check if the index n is valid in the list
dnl-init( dnl -- ) Initialise the list
dnl-insert( dnn n dnl -- ) Insert the node dnn before the nth node in the list
dnl-insert-after( dnn1 dnn2 dnl -- ) Insert the new node dnn1 after the reference node dnn2 in the list
dnl-insert-before( dnn1 dnn2 dnl -- ) Insert the new node dnn1 before the reference node dnn2 in the list
dnl-last@( dnl -- dnn | nil ) Get the last node in the list
dnl-length@( dnl -- u ) Get the number of nodes in the list
dnl-new( -- dnl ) Create a new dnl list on the heap
dnl-pop( dnl -- dnn | nil ) Pop the node dnn from the end of the list
dnl-prepend( dnn dnl -- ) Prepend the node dnn in the list
dnl-push( dnn dnl -- ) Push the node dnn at the end of the list
dnl-remove( dnn dnl -- ) Remove the node dnn from the list
dnl-reverse( dnl -- ) Reverse or mirror the list
dnl-tos( dnl -- dnn | nil ) Get the node dnn from the end of the list
dnn%( -- n ) Get the required space for a dnn structure
dnn-dump( dnn -- ) Dump the node
dnn-free( dnn -- ) Free the node from the heap
dnn-init( dnn -- ) Initialise the node
dnn-new( -- dnn ) Create a new node on the heap
dnn-next!( dnn1 dnn2 -- ) Set for node dnn2 the next node to dnn1
dnn-next@( dnn1 -- dnn2 ) Get the next node dnn2 from node dnn1
dnn-prev!( dnn1 dnn2 -- ) Set for node dnn2 the previous node to dnn1
dnn-prev@( dnn1 -- dnn2 ) Get from node dnn1 the previous node
do-log( c-addr u n -- ) Log the message c-addr u with event n
dom%( -- n ) Get the required space for a dom variable
dom-(free)( dom -- ) Free the internal, private variables from the heap
dom-append-node( i*x n dom -- ) Append a node to the current node, exception if not allowed, iterator is moved to the new node
dom-child( dom -- n true | false ) Move the iterator to the first child node, return the xml type of this node
dom-children( dom -- n ) Return the number of children for the current node
dom-children?( dom -- flag ) Check if the current node has children
dom-create( "<spaces>name" -- ; -- dom ) Create a named DOM in the dictionary
dom-document( dom -- true | false ) Move the iterator to the document [=root] node
dom-document?( dom -- flag ) Check if the current node is the document [=root] node
dom-dump( dom - ) Dump the DOM tree
dom-first( dom -- n true | false ) Move the iterator to the first sibling node, return the xml type of this node
dom-first?( dom -- flag ) Check if the current node is the first sibling node
dom-free( dom -- ) Free the DOM from the heap
dom-get( dom -- n true | false ) Get the xml node type of the current node
dom-get-name( dom -- c-addr u ) Get the name from the current node
dom-get-type( dom -- n ) Get the xml node type of the current node
dom-get-value( dom -- c-addr u ) Get the value from the current node
dom-init( dom -- ) Initialise the DOM
dom-insert-node-after( i*x n -- ) Insert a node after the current node, exception if not allowed
dom-insert-node-before( i*x n dom -- ) Insert a node before the current node, exception if not allowed
dom-last( dom -- n true | false ) Move the iterator to the last sibling node, return the xml type of this node
dom-last?( dom -- flag ) Check if the current node is the last sibling node
dom-new( -- dom ) Create a new DOM on the heap
dom-next( dom -- n true | false ) Move the iterator to the next sibling node, return the xml type of this node
dom-parent( dom -- n true | false ) Move the iterator to the parent node, return the xml type of this node
dom-prev( dom -- n true | false ) Move the iterator to the previous sibling node, return the xml type of this node
dom-read-reader( x xt flag1 dom -- flag2 ) Read xml source with the reader xt with its state x into the dom tree, flag1 indicates whitespace stripping, throw exception if tree is not empty, return success in flag2
dom-read-string( c-addr u flag1 dom -- flag2 ) Read xml source from the string c-addr u into the dom tree, flag1 indicates whitespace stripping, throw exception if tree is not empty, return success in flag2
dom-remove( dom -- flag ) Remove the current sibling node without children from the tree, iterator is moved to the next, previous or parent node, return the removed node
dom-set( i*x dom -- ) Update the current node
dom-write-string( dom -- c-addr u true | false ) Write the tree to xml returning a string c-addr u if successful
dom-write-writer( x xt dom -- flag ) Write the tree to xml using writer xt and its data x, flag indicate success
dom.attribute( -- n ) DOM node: Attribute
dom.cdata( -- n ) DOM node: CDATA
dom.comment( -- n ) DOM node: Comment
dom.doc-fragment( -- n ) DOM node: Document fragment [not used]
dom.doc-type( -- n ) DOM node: Document type [not used]
dom.document( -- n ) DOM node: Start document
dom.element( -- n ) DOM node: Tag
dom.entity( -- n ) DOM node: Entitiy [not used]
dom.entity-ref( -- n ) DOM node: Entity reference [not used]
dom.not-used( -- n ) DOM node: Not used
dom.notation( -- n ) DOM node: Notation [not used]
dom.pi( -- n ) DOM node: Processing Instruction
dom.text( -- n ) DOM node: Text
dos-write-12hour( dtm tos -- ) Write the hour using a 12-hour clock: 01..12
dos-write-24hour( dtm tos -- ) Write the hour using a 24-hour clock: 00..23
dos-write-2year( dtm tos -- ) Write the year without the century: 00..99
dos-write-abbr-month-name( dtm tos -- ) Write the abbreviated month name, using the streams catalog for locale
dos-write-abbr-weekday-name( dtm tos -- ) Write the abbreviated weekday name, using the streams catalog for locale
dos-write-american-date( dtm tos -- ) Write the date in mm/dd/yy format
dos-write-ampm( dtm tos -- ) Write the am or pm notation, using the streams catalog for locale
dos-write-ampm-time( dtm tos -- ) Write the time in ampm notation: hh:mm:ss ?m, using the streams catalog for locale
dos-write-century( dtm tos -- ) Write the century number
dos-write-date( dtm tos -- ) Write the preferred date using the streams catalog for the locale, else yyyy/mm/dd
dos-write-date-time( dtm tos -- ) Write the preferred time and date using the streams catalog for the locale, else yyyy/mm/dd hh:mm:ss
dos-write-format( dtm c-addr u tos -- ) Write date and time info with the format string c-addr u in the stream tos
dos-write-hhmm-time( dtm tos -- ) Write the time: hh:mm
dos-write-hhmmss-time( dtm tos -- ) Write the time: hh:mm:ss
dos-write-iso8601-date( dtm tos -- ) Write the date in ISO 8601 format: yyyy-mm-dd
dos-write-minute( dtm tos -- ) Write the minute: 00..59
dos-write-month( dtm tos -- ) Write the month: 01..12
dos-write-month-name( dtm tos -- ) Write the full month name, using the streams catalog for locale
dos-write-monthday( dtm tos -- ) Write the day of the month: 01..31
dos-write-seconds( dtm tos -- ) Write the number of seconds: 00..61
dos-write-seconds-since-epoch( dtm tos -- ) Write the number of seconds since 1970-01-01 00:00:00
dos-write-spaced-12hour( dtm tos -- ) Write the hour using a 12-hour clock:  1..12, space padded
dos-write-spaced-24hour( dtm tos -- ) Write the hour using a 24-hour clock:  0..23, space padded
dos-write-spaced-monthday( dtm tos -- ) Write the day of the month,  1..31, space padded
dos-write-time( dtm tos -- ) Write the preferred time using the stream catalog for the locale, else hh:mm:ss
dos-write-upper-ampm( dtm tos -- ) Write the AM or PM notation, using the streams catalog for locale
dos-write-week-number( dtm tos -- ) Write the week number: 01..53
dos-write-weekday( dtm tos -- ) Write the weekday: 0..6, 0 = sunday
dos-write-weekday-name( dtm tos -- ) Write the full weekday name, using the streams catalog for locale
dos-write-year( dtm tos -- ) Write the year including the century
dos-write-yearday( dtm tos -- ) Write the day of the year: 001..366
dti-day+( dtm -- ) Increase the date/time with one day
dti-day-( dtm -- ) Decrease the date/time with one day
dti-days+( d dtm -- ) Increase the date/time with d days
dti-days-( d dtm -- ) Decrease the date/time with d days
dti-hour+( dtm -- ) Increase the date/time with one hour
dti-hour-( dtm -- ) Decrease the date/time with one hour
dti-milli+( dtm -- ) Increase the date/time with one millisecond
dti-milli-( dtm -- ) Decrease the date/time with one millisecond
dti-minute+( dtm -- ) Increase the date/time with one minute
dti-minute-( dtm -- ) Decrease the date/time with one minute
dti-month+( dtm -- ) Increase the date/time with one months
dti-month-( dtm -- ) Decrease the date/time with one months
dti-second+( dtm -- ) Increase the date/time with one second
dti-second-( dtm -- ) Decrease the date/time with one second
dti-seconds+( d dtm -- ) Increase the date/time with d seconds
dti-seconds-( d dtm -- ) Decrease the date/time with d seconds
dti-year+( dtm -- ) Increase the date/time with one year
dti-year-( dtm -- ) Decrease the date/time with one year
dtm%( -- n ) Get the required space for a dtm variable
dtm+calc-leap-years( n1 n2 -- n3 ) Calculate the number of leap years in the year range [n2..n1]
dtm+day?( n1 n2 n3 -- flag ) Check if the day n1 in the month n2 and year n3 is valid
dtm+days-in-month( n1 n2 -- n3 ) Get the number of days in the month n1 and year n2
dtm+days-in-year( n1 -- n2 ) Get the number of days in the year n1
dtm+days-till-month( n1 n2 -- n3 ) Get the number of days till the month n1 and year n2
dtm+hour?( n -- flag ) Check if the hours n are valid
dtm+leap-year?( n -- flag ) Check if the year n is a leap year
dtm+milli?( n -- flag ) Check if the milliseconds n are valid
dtm+minute?( n -- flag ) Check if the minutes n are valid
dtm+month?( n -- flag ) Check if the month n is valid
dtm+second?( n -- flag ) Check if the seconds n are valid
dtm+year?( n -- flag ) Check if the year n [>1582] is valid
dtm-calc-days-since-epoch( n dtm -- d ) Calculate the number of days since epoch n from the date
dtm-calc-seconds-since-epoch( n dtm -- d ) Calculate the number of seconds since epoch n from the date/time
dtm-compare( n1 n2 n3 n4 n5 n6 n7 dtm -- n ) Compare the date/time with milliseconds n1, seconds n2, minutes n3, hours n4, day n5, month n6 and year n7
dtm-create( "<spaces>name" -- ; -- dtm ) Create a date/time variable in the dictionary with the current date/time
dtm-day!( n dtm -- ) Set the day
dtm-day@( dtm -- n ) Get the day
dtm-dump( dtm -- ) Dump the date/time variable
dtm-free( dtm -- ) Free the date/time variable from the heap
dtm-get( dtm -- n1 n2 n3 n4 n5 n6 n7 ) Get the date/time, return milliseconds n1, seconds n2, minutes n3, hours n4, day n5, month n6 and year n7
dtm-get-date( dtm -- n1 n2 n3 ) Get the date, return day n1, month n2 and year n3
dtm-get-time( dtm -- n1 n2 n3 n4 ) Get the time, return milliseconds n1, seconds n2, minutes n3 and hours n4
dtm-hour!( n dtm -- ) Set the hour
dtm-hour@( dtm -- n ) Get the hour
dtm-init( dtm -- ) Initialise the date/time with the current date and time
dtm-iso-weeknumber( dtm -- n1 n2 ) Get the iso week number n1 and year n2 from the date
dtm-milli!( n dtm -- ) Set the milliseconds
dtm-milli@( dtm -- n ) Get the milliseconds
dtm-minute!( n dtm -- ) Set the minutes
dtm-minute@( dtm -- n ) Get the minutes
dtm-month!( n dtm -- ) Set the month
dtm-month@( dtm -- n ) Get the month
dtm-new( -- dtm ) Allocate a date/time variable on the heap with the current date/time
dtm-second!( n dtm -- ) Set the seconds
dtm-second@( dtm -- n ) Get the seconds
dtm-set( n1 n2 n3 n4 n5 n6 n7 dtm -- ) Set the date/time with milliseconds n1, seconds n2, minutes n3, hours n4, day n5, month n6 and year n7
dtm-set-date( n1 n2 n3 dtm -- ) Set the date with day n1, month n2 and year n3
dtm-set-now( dtm -- ) Set the date time with the current date/time
dtm-set-time( n1 n2 n3 n4 dtm -- ) Set the time with milliseconds n1, seconds n2, minutes n3 and hours n4
dtm-set-with-days( d1 n2 dtm -- ) Set the date with days d1 since epoch n2
dtm-set-with-seconds( d n dtm -- ) Set the date/time with d seconds since epoch n
dtm-weekday( dtm -- n ) Get the week day from the date
dtm-year!( n dtm -- ) Set the year
dtm-year@( dtm -- n ) Get the year
dtm-yearday( dtm -- n ) Get the day number [in the year] from the date
dtm.april( -- n ) April
dtm.august( -- n ) August
dtm.december( -- n ) December
dtm.february( -- n ) February
dtm.friday( -- n ) Friday
dtm.january( -- n ) January
dtm.july( -- n ) July
dtm.june( -- n ) June
dtm.march( -- n ) March
dtm.may( -- n ) May
dtm.monday( -- n ) Monday
dtm.november( -- n ) November
dtm.october( -- n ) October
dtm.saturday( -- n ) Saturday
dtm.september( -- n ) September
dtm.start-epoch( -- n ) Start epoch [1583]
dtm.sunday( -- n ) Sunday
dtm.thursday( -- n ) Thursday
dtm.tuesday( -- n ) Tuesday
dtm.unix-epoch( -- n ) Unix epoch [1970]
dtm.wednesday( -- n ) Wednesday
dtm^compare( dtm1 dtm2 -- n ) Compare two date/times, return the compare result [-1,0,1]
end-enumeration( enum-sys -- ) End an enumeration definition
end-of-line( -- c-addr ) Counted string for the end of line for the current system
end-stringtable( stringtable-sys -- ) End the stringtable definition
end-structure( structure-sys -- ) End a structure definition
enum:( enum-sys "<spaces>name" -- enum-sys ;  -- n ) Define an enumeration, increment for the next enumeration, return the enum value
error"( "ccc<quote>" -- ) Log an error message
exp-index-out-of-range( -- n ) Index out of range exception number
exp-invalid-data( -- n ) Invalid data exception number
exp-invalid-parameters( -- n ) Invalid parameters on stack
exp-invalid-state( -- n ) Invalid state exception number
exp-no-data( -- n ) No data available exception number
exp-wrong-checksum( -- n ) Wrong checksum
exp-wrong-file-data( -- n ) Wrong file data
exp-wrong-file-type( -- n ) Wrong file type
exp-wrong-file-version( -- n ) Wrong file version
exp-wrong-length( -- n ) Wrong length
f-rot( F: r1 r2 r3 -- r3 r1 r2 ) Rotate counter clockwise three floats
f2dup( F: r1 r2 -- r1 r2 r1 r2 ) Duplicate two floats
f>r( F: r -- ; R: -- r ) Push float on the return stack
fatal"( "ccc<quote>" -- ) Log a fatal message
ffield:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of 1 float, return the field address
ffields:( structure-sys n "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of n floats, return the field address
field:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of 1 cell, return the field address
fields:( structure-sys n "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of n cells, return the field address
fr>( F: -- r ; R: r -- ) Pop float from the return stack
fr@( F: -- r ; R: r -- r ) Get float from top of return stack
frc%( -- n ) Get the required space for a frc variable
frc+abs( n1 n2 -- n3 n4 ) Absolute the fraction n1/n2, return n3/n4
frc+add( n1 n2 n3 n4 -- n5 n6 ) Add two fractions n1/n2 and n3/n4, return n5/n6
frc+calc-gcd( n1 n2 -- +n ) Calculate the Greatest Common Divider
frc+calc-lcm( n1 n2 -- +n ) Calculate the Least Common Multiplier
frc+compare( n1 n2 n3 n4 -- n ) Compare the fractions n1/n2 and n3/n4, return the result [-1,0,1]
frc+divide( n1 n2 n3 n4 -- n5 n6 ) Divide fraction n1/n2 by fraction n3/n4, return n5/n6
frc+invert( n1 n2 -- n3 n4 ) Invert the fraction n1/n2, return n3/n4
frc+multiply( n1 n2 n3 n4 -- n5 n6 ) Multiply fraction n1/n2 by fraction n3/n4, return n5/n6
frc+negate( n1 n2 -- n3 n4 ) Negate the fraction n1/n2, return n3/n4
frc+norm( n1 n2 -- n3 n4 ) Normalize a fraction n1/n2, return n3/n4
frc+subtract( n1 n2 n3 n4 -- n5 n6 ) Subtract fraction n3/n4 from fraction n1/n2, return n5/n6
frc+to-float( n1 n2 -- r ) Convert fraction n1/n2 to float value
frc+to-string( n1 n2 -- c-addr u ) Convert fraction n1/n2 to a string using the pictured output area
frc-create( "<spaces>name" -- ; -- frc ) Create a named fraction in the dictionary
frc-denom@( frc -- n ) Get the denominator
frc-dump( frc -- ) Dump the fraction
frc-free( frc -- ) Free the fraction from the heap
frc-get( frc -- n1 n2 ) Get the fraction n1/n2
frc-init( frc -- ) Initialise the fraction to zero
frc-new( -- frc ) Create a new fraction on the heap
frc-num@( frc -- n ) Get the numerator
frc-set( n1 n2 frc ) Normalize and set the fraction n1/n2
frc^compare( frc2 frc1 -- n ) Compare fraction2 with fraction1, return the result [-1,0,1]
frc^move( frc2 frc1 -- ) Move frc2 in frc1
fsm%( -- n ) Get the required space for a fsm variable
fsm-(free)( fsm -- ) Free the internal, private variables from the heap
fsm-any-transition( x xt c-addr1 u1 fst1 fst2 fsm -- ftr ) Set the any transition for state fst1 to state fst2 with label c-addr1 u1, action xt and data x
fsm-create( "<spaces>name" +n -- ; -- fsm ) Create a named fsm in the dictionary with the number of events n
fsm-dump( fsm -- ) Dump the fsm variable
fsm-feed( n fsm -- fst | nil ) Feed the event to the current state, return the next state or nil if the event did not match any condition
fsm-find-state( c-addr u fsm -- fst | nil ) Find the state by its label c-addr u in the fsm
fsm-free( fsm -- ) Free the fsm from the heap
fsm-init( +n fsm -- ) Initialise the fsm with the number of events n
fsm-new( +n -- fsm ) Create a new fsm on the heap with the number of events n
fsm-new-state( x xt1 xt2 c-addr1 u1 fsm -- fst ) Add a new state with label c-addr1 u1, entry action xt1, exit action xt2 and data x
fsm-new-transition( x xt c-addr1 u1 fst1 fst2 fsm -- ftr ) Add a new transition from state fst1 to state fst2 with label c-addr1 u1, action xt and data x
fsm-start( fsm -- ) Start the finite state machine
fsm-start!( fst fsm -- ) Set the start state
fsm-start@( fsm -- fst ) Get the start state
fsm-to-dot( c-addr u tos fsm -- ) Convert the fsm to a dot string using the stream, giving the graph the name c-addr u
fsm-try( n fsm -- fst | nil ) Try the event for the current event, return the next state, but do not move to this state
fst%( -- n ) Get the required space for a state variable
fst-(free)( fst -- ) Free the internal, private variables from the heap
fst-any-transition( x xt c-addr u fst1 fst -- ftr ) Set the any transition to state fst1 with label c-addr u, action xt and data x
fst-attributes!( c-addr u fst -- ) Set the extra graphviz attributes for the state
fst-attributes@( fst -- c-addr u ) Get the extra graphviz attributes of the state
fst-data!( x fst -- ) Set the data for the state
fst-data@( fst -- x ) Get the data of the state
fst-dump( fst -- ) Dump the fst variable
fst-entry@( fst -- xt ) Get the entry action of the state
fst-exit@( fst -- xt ) Get the exit action of the state
fst-feed( n fst -- fst | nil ) Feed the event to this state, return the next state or nil if the event did not match any condition
fst-find-transition( c-addr u fst -- ftr | nil ) Find the transition with label c-addr u, else return nil
fst-free( fst -- ) Free the state from the heap
fst-id@( fst -- n ) Get the id of the state
fst-init( x xt1 xt2 c-addr u n fst -- ) Initialise the state with id n and label c-addr u, entry action xt1, exit action xt2 and data x
fst-label?( c-addr u fst -- c-addr u false | fst true ) Check the label c-addr u with this state
fst-label@( fst -- c-addr u ) Get the label of the state
fst-new( x xt1 xt2 c-addr u n -- fst ) Create a new state on the heap with id n, label c-addr u, entry action xt1, exit action xt2 and data x
fst-new-transition( x xt c-addr u fst1 n fst -- ftr ) Add a new transition to state fst1 with label c-addr u, number events n, action xt and data x
fst-try( n fst -- fst | nil ) Try the event for this state, return the result
ftr%( -- n ) Get the required space for a transition variable
ftr-(free)( ftr -- ) Free the internal, private variables from the heap
ftr-action@( ftr -- xt ) Get the action of the transition
ftr-attributes!( c-addr u ftr -- ) Set the extra graphviz attributes for the transition
ftr-attributes@( ftr -- c-addr u ) Get the extra graphviz attributes of the transition
ftr-condition@( ftr -- bar ) Get the condition of the transition as reference to a bit array
ftr-data!( x ftr -- ) Set the data for the transition
ftr-data@( ftr -- x ) Get the data of the transition
ftr-dump( ftr -- ) Dump the transition
ftr-feed( n ftr -- n false | fst true ) Feed the event to this transition, return the next state or the event if the event did not match the condition
ftr-fire( n ftr -- fst ) Fire the transition for event n, without checking the condition
ftr-free( ftr -- ) Free the transition from the heap
ftr-init( x xt c-addr u fst +n ftr -- ) Initialise the transition to the state fst, with label c-addr u, number events n, action xt and data x
ftr-label?( c-addr u ftr -- ftr true | c-addr u false ) Check the label c-addr u with the transition ftr
ftr-label@( ftr -- c-addr u ) Get the label of the transition
ftr-new( x xt c-addr u fst +n -- ftr ) Create a new transition on the heap to the state fst, with label c-addr u, number events n, action xt and data x
ftr-try( n ftr -- n false | fst true ) Try the event for this transition, return the result
gmo-read( c-addr u msc -- 0 | ior ) Read a mo-file named c-addr u and store the contents in the message catalog msc
gsv+call( c-addr1 u1 -- c-addr2 u2 ) Call the gtk-server with command c-addr1 u1, resulting in response c-addr2 u2
gsv+close( -- ior ) Close the connection to the gtk-server, the gtk-server is *NOT* closed
gsv+connect( c-addr u -- ior ) Connect to the gtk-server via a fifo c-addr u
gsv+disconnect( -- ior ) Disconnect from the gtk-server, the gtk-server is *NOT* closed
gsv+open( c-addr1 u1 c-addr2 u2 -- ior ) Open the connection to the gtk-server by reading the configuration file c-addr1 u1 and connecting to c-addr2 u2
gsv+server-connect( n1 c-addr1 u1 n2 -- c-addr2 u2 ) Call gtk_server_connect with widgetid n2, signal c-addr1 u1 and description n2, returning the result c-addr2 u2
gsv+server-connect-after( n1 c-addr1 u1 n2 -- c-addr2 u2 ) Call gtk_server_connect_after with widgetid n2, signal c-addr1 u1 and description n2, returning the result c-addr2 u2
gzf%( -- n ) Get the required space for a gzf variable
gzf-(free)( gzf -- ) Free the internal, private variables from the heap
gzf-comment!( c-addr u gzf -- ) Set the comment for the next file in the gzip file
gzf-comment@( gzf -- c-addr u ) Get the comment of the current file in the gzip file
gzf-create( "<spaces>name" -- ; -- gzf ) Create a named gzip file variable in the dictionary
gzf-dump( gzf -- ) Dump the variable
gzf-flags!( u gzf -- ) Set the flags for the gzip file header
gzf-flags@( gzf -- u ) Get the flags from the gzip file header
gzf-free( gzf -- ) Free the variable from the heap
gzf-init( gzf -- ) Initialise the gzip file variable
gzf-mtime!( u gzf -- ) Set the modification time for the next file in the gzip file in seconds since unix epoch
gzf-mtime@( gzf -- u ) Get the modification time of the current file in the gzip file in seconds since unix epoch
gzf-name!( c-addr u gzf -- ) Set the name of the next file in the gzip file
gzf-name@( gzf -- c-addr u ) Get the name of the current file in the gzip file
gzf-new( -- gzf ) Create a new gzip file variable on the heap
gzf-os!( n gzf -- ) Set the operating system for the next file in the gzip file
gzf-os@( gzf -- n ) Get the operating system of the current file in the gzip file
gzf-reset( gzf -- ) Reset the gzip file header
gzf-text!( flag gzf -- ) Set if the source for the next file in the gzip file is text
gzf-text@( gzf -- flag ) Get if the source of the current file in the gzip file is text
gzf.acorn( -- n ) ACORN OS
gzf.amiga( -- n ) Amiga OS
gzf.atari( -- n ) ATARI OS
gzf.cp/m( -- n ) CP-M OS
gzf.deflate( -- n ) Deflate Compression mode
gzf.fat( -- n ) FAT OS
gzf.hpfs( -- n ) HPFS OS
gzf.macintos( -- n ) MACINTOS OS
gzf.ntfs( -- n ) NTFS OS
gzf.qdos( -- n ) QDOS OS
gzf.tops-20( -- n ) TOPS-20 OS
gzf.unix( -- n ) UNIX OS
gzf.unknown( -- n ) other
gzf.vm/cms( -- n ) VM-CMS OS
gzf.vms( -- n ) VMS OS
gzf.z-system( -- n ) Z-SYSTEM OS
gzi%( -- n ) Get the required space for a gzi variable
gzi-(free)( gzi -- ) Free the internal, private variables from the heap
gzi-create( "<spaces>name" u -- ; -- gzi ) Create a named gzip inflation variable in the dictionary with an initial output buffer size u
gzi-dump( gzi -- ) Dump the gzi
gzi-end-inflate( gzi -- ) Finish the inflation of data
gzi-free( gzi -- ) Free the variable from the heap
gzi-inflate( gzi -- ior ) Do the next step in inflating data, return the result code
gzi-init( u gzi -- ) Initialise the gzip inflation variable with an initial output buffer size u
gzi-init-inflate( gzi -- ) Start the inflation of data
gzi-lbf@( gzi -- lbf ) Get the output buffer
gzi-new( -- gzi ) Create a new gzip inflation variable on the heap
gzi-reduce-output( gzi -- ) Check if the output buffer can be reduced
gzi.done( -- n ) Decompression is done
gzi.more( -- n ) Decompression step needs more data
gzi.ok( -- n ) Decompression step is okee
gzi.states( -- n ) Decompression step states
hci%( -- n ) Get the required space for a hash cell table iterator
hci-create( hct "<spaces>name" -- ; -- hci ) Create a named iterator in the dictionary on the hash table hct
hci-dump( hci -- ) Dump the iterator
hci-first( hci -- x true | false ) Move the iterator to the first record, return the cell data of this record
hci-first?( hci -- flag ) Check if the iterator is on the first record
hci-free( hci -- ) Free the iterator from heap
hci-get( hci -- false | x true ) Get the cell data x from the current record
hci-init( hct hci -- ) Initialise the iterator with a hash table
hci-key( hci -- c-addr u ) Get the key from the current record
hci-last?( hci -- flag ) Check if the iterator is on the last record
hci-move( x hci -- flag ) Move the iterator to the next record with the cell data x, return success
hci-new( hct -- hci ) Create an iterator on the heap on the hash table hct
hci-next( hci -- x true | false ) Move the iterator to the next record, return the cell data from this record
hci-set( x hci -- ) Set the cell data x in the current record
hcn%( - n ) Get the required space for a hcn node
hcn-(free)( hcn -- ) Free the key from the heap
hcn-dump( hcn -- ) Dump the node
hcn-free( hcn -- ) Free the node from the heap
hcn-init( x c-addr u u2 hcn -- ) Initialise the node with the hash u2, the key c-addr u and cell data x
hcn-new( x c-addr u u2 -- hcn ) Create a new node on the heap with the hash u2, the key c-addr u and cell data x
hct%( -- n ) Get the required space for a hash table variable
hct+hash( c-addr1 u1 -- u2 ) Calculate the hash value of a key
hct-(free)( hct -- ) Free the nodes from the hash table
hct-count( x hct -- u ) Count the number of occurrences of the cell data x in the table
hct-create( u "<spaces>name" -- ; -- hct ) Create a named hash table with an initial size u in the dictionary
hct-delete( c-addr u hct -- false | x true ) Delete the key c-addr u from the table, return the cell data related to the key
hct-dump( hct -- ) Dump the hash table
hct-empty?( hct -- flag ) Check if the table is empty
hct-execute( i*x xt hct -- j*x ) Execute xt for every key and cell data in table
hct-free( hct -- ) Free the hash table from the heap
hct-get( c-addr u hct -- false | x true ) Get the cell data x related to the key c-addr u from the table
hct-has?( c-addr u hct -- flag ) Check if the key c-addr u is present in the table
hct-init( u hct -- ) Initialise the hash table with an initial size u
hct-insert( x c-addr u hct -- ) Insert cell data x with the key c-addr u in the table
hct-length@( hct -- u ) Get the number of nodes in the table
hct-load!( u hct -- ) Set the load factor [*100%]
hct-load@( hct -- u ) Get the load factor [*100%]
hct-new( u -- hct ) Create a hash table with an initial size u on the heap
hct-size!( u hct -- ) Resize the hash table to size u
hni%( -- n ) Get the required space for a hash table base iterator variable
hni-create( hnt "<spaces>name" -- ; -- hni ) Create a named iterator in the dictionary on the hash table hnt
hni-dump( hni -- ) Dump the iterator
hni-first( hni -- hnn | nil ) Move the iterator to the first record, return the node in this record
hni-first?( hni -- flag ) Check if the iterator is on the first record
hni-free( hni -- ) Free iterator from heap
hni-get( hni -- hnn | nil ) Get the node from the current record
hni-init( hnt hni -- ) Initialise the iterator with the hash table hnt
hni-key( hni -- c-addr u ) Get the key from the current record
hni-last?( hni -- flag ) Check if the iterator is on the last record
hni-new( hnt -- hni ) Create an iterator on the heap on the hash table hnt
hni-next( hni -- hnn | nil ) Move the iterator to the next record, return the node in this record
hnn%( -- n ) Get the required space for a hnn node
hnn-(free)( hnn -- ) Free the key from the heap
hnn-dump( hnn -- ) Dump the node
hnn-free( hnn -- ) Free the node from the heap
hnn-init( c-addr u u2 hnn -- ) Initialise the node with the key c-addr u and hash u2
hnn-key@( hnn -- c-addr u ) Get the key from the node
hnn-new( c-addr u u2 -- hnn ) Create a new node on the heap with the key c-addr u and hash u2
hnt%( -- n ) Get the required space for a hash table variable
hnt+hash( c-addr1 u1 -- u2 ) Calculate the hash value of the key c-addr1 u1
hnt-(free)( xt hnt -- ) Free the nodes from the heap using xt
hnt-create( u "<spaces>name" -- ; -- hnt ) Create a named hash table with an initial size u in the dictionary
hnt-delete( c-addr u hnt -- nil | hnn ) Delete the key c-addr u from the table, return the deleted node hnn
hnt-dump( hnt -- ) Dump the hash table
hnt-empty?( hnt -- flag ) Check for an empty table
hnt-execute( i*x xt hnt -- j*x ) Execute xt for every key and node in table
hnt-free( hnt -- ) Free the hash table from the heap
hnt-get( c-addr u hnt -- nil | hnn ) Get the node related to the key c-addr u from the table, return the node hnn
hnt-has?( c-addr u hnt -- flag ) Check if the key c-addr u is present in the table
hnt-init( u hnt -- ) Initialise the hash table with an initial size u
hnt-insert( hnn hnt -- ) Insert the node hnn in the table, double keys are NOT checked
hnt-length@( hnt -- u ) Get the number of nodes in the table
hnt-load!( u hnt -- ) Set the load factor [*100%]
hnt-load@( hnt -- u ) Get the load factor [*100%]
hnt-new( u -- hnt ) Create a hash table with an initial size u on the heap
hnt-search( c-addr u hnt -- u hnn ) Search the node based on the key, return the hash u and the node hnn
hnt-size!( u hnt -- ) Resize the hash table
icompare( c-addr1 u1 c-addr2 u2 -- n ) Compare case-insensitive two strings and return the result [-1,0,1]
index2offset( n1 n2 -- n3 ) Convert the index n1 range [-n2..n2> into offset n3 range [0..n2>, negative values of n1 downward length n2
info"( "ccc<quote>" -- ) Log an info message
l!( n l-addr -- ) Store a long word, 32 bit
l+!( l l-addr -- ) Add l to l-addr
l+!( l l-addr -- ) Add l to l-addr
l,( x -- ) Store 32 bits of data in the data storage
l,( x -- ) Store 32 bits of data in the data storage
l@( l-addr -- n ) Fetch a long word, 32 bit, zero extend
l@!( l1 l-addr -- l2 ) Fetch l2 from l-addr and then store l1 at l-addr
l@!( l1 l-addr -- l2 ) Fetch l2 from l-addr and then store l1 at l-addr
lbf%( -- n ) Get the required space for a lbf variable
lbf+extra!( u -- ) Set the initial extra space allocated during resizing of the buffer
lbf+extra@( -- u ) Get the initial extra space allocated during resizing of the buffer
lbf-(free)( lbf -- ) Free the internal data from the heap
lbf-access!( xt1 xt2 lbf -- ) Set the store word xt1 and the fetch word x2 for the buffer
lbf-access@( lbf -- xt1 xt2 ) Get the store word xt1 and the fetch word xt2 for the buffer
lbf-clear( lbf -- ) Clear the buffer
lbf-copy( u1 u2 lbf -- ) Copy records u1 times from distance u2, u1 >= u2 is allowed
lbf-create( +n1 +n2 "<spaces>name" -- ; -- lbf ) Create a linear buffer in the dictionary with element size n1 and initial length n2
lbf-dequeue( lbf -- i*x true | addr true | false ) Dequeue one element from the buffer, using the fetch word if available
lbf-dump( lbf -- ) Dump the linear buffer variable
lbf-enqueue( i*x lbf | addr lbf -- ) Enqueue one element in the buffer, using the store word if available
lbf-extra!( u lbf -- ) Set the extra space allocated during resizing of the buffer
lbf-extra@( lbf -- u ) Get the extra space allocated during resizing of the buffer
lbf-fetch( u1 lbf -- addr u2 | 0 ) Fetch maximum u1 elements from the buffer, return the actual number of elements u2
lbf-free( lbf -- ) Free the linear buffer from the heap
lbf-gap@( lbf -- u ) Get the number of elements between the out pointer and the secondary out pointer
lbf-get( u1 lbf -- addr u2 | 0 ) Get maximum u1 elements from the buffer, return the actual number of elements u2
lbf-get'( u1 lbf -- addr u2 | 0 ) Get maximum u1 elements from the buffer, based on secondary out, return the actual number of elements u2
lbf-init( +n1 +n2 lbf -- ) Initialise the buffer with element size n1 and initial length n2
lbf-length'@( lbf -- u ) Get the number of elements in the buffer based on the secondary out pointer
lbf-length@( lbf -- u ) Get the number of elements in the buffer
lbf-new( +n1 +n2 -- lbf ) Create a linear buffer with element size n1 and initial length n2 on the heap
lbf-pop( lbf -- i*x true | addr true | false ) Pop one element from the buffer, using the fetch word if available
lbf-push( i*x lbf | addr lbf -- ) Push one element in the buffer, using the store word if available
lbf-reduce( u lbf -- ) Remove the leading unused space in the buffer if the unused length is at least u elements
lbf-set( addr u lbf -- ) Set u elements, starting from addr in the buffer, resize if necessary
lbf-size!( +n lbf -- ) Insure the size of the buffer
lbf-skip( u1 lbf -- u2 ) Skip maximum u1 elements from the buffer, return the actual skipped elements u2
lbf-tos( lbf -- i*x true | addr true | false ) Fetch the top element, using the fetch word if available
lfield:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field for a long word, 4 bytes, not aligned, return the field address
lfields:( structure-sys n "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field for n long words, not aligned, return the field address
llroll( l1 u2 -- l3 ) Rotate l1 u2 bits to the left
llroll( l1 u2 -- l3 ) Rotate l1 u2 bits to the left
log-from-level( n -- ) Skip and suppress all events below level n
log-stack-depth( n -- ) Append max n top stack elements to the log message
log-to-callback( xt -- ) Start logging to the xt callback
log-to-console( -- ) Start logging to the console
log-to-file( fileid -- ) Start logging to the file
log-to-rolling( c-addr u n1 n2 -- ) Start logging to rolling files, with names starting with c-addr u, maximum n1 files and n2 entries in one file
log-with-flush( flag -- ) Set if the log line should be flushed to file
log-with-time&date( flag -- ) Set if the time&date should start the log message
log.debug( -- n ) the debug event
log.error( -- n ) the error event
log.fatal( -- n ) the fatal event
log.info( -- n ) the info event
log.none( -- n ) disable all events
log.trace( -- n ) the trace event
log.warning( -- n ) the warning event
lroll( u1 u2 -- u3 ) Rotate u1 u2 bits to the left
lrroll( l1 u2 -- l3 ) Rotate l1 u2 bits to the right
lrroll( l1 u2 -- l3 ) Rotate l1 u2 bits to the left
max-ms@( -- u ) Maximum value of the milliseconds timer
md5%( -- n ) Get the required space for a md5 variable
md5+to-string( u1 u2 u3 u4 -- c-addr u ) Convert MD5 result to the string, using the pictured output area
md5-create( "<spaces>name" -- ; -- md5 ) Create a named MD5 variable in the dictionary
md5-dump( md5 -- ) Dump the md5 variable
md5-finish( md5 -- u1 u2 u3 u4 ) Finish the MD5 calculation, return the result u1 u2 u3 u4
md5-free( md5 -- ) Free the MD5 variable from the heap
md5-init( md5 -- ) Initialise the MD5 variable
md5-new( -- md5 ) Create a new MD5 variable on the heap
md5-reset( md5 -- ) Reset the MD5 state
md5-update( c-addr u md5 -- ) Update the MD5 with more data c-addr u
ms@( -- u ) Fetch milliseconds timer
msc%( -- n ) Get the required space for a message catalog
msc-(free)( msc -- ) Free the catalogs nodes from the heap
msc-add( c-addr1 u1 c-addr2 u2 msc -- ) Add the message c-addr1 u1 and translation c-addr2 u2 to the catalog
msc-create( "<spaces>name" --  ; -- msc ) Create a named message catalog in the dictionary
msc-dump( msc -- ) Dump the message catalog
msc-free( msc -- ) Free the message catalog from the heap
msc-init( msc -- ) Initialise the catalog
msc-new( -- msc ) Create a message catalog on the heap
msc-remove( c-addr u msc -- flag ) Remove the message c-addr u from the catalog, return success
msc-translate( c-addr1 u1 msc -- c-addr2 u2 ) Translate the message c-addr1 u1 with the catalog, return message if not found
msc-translate?( c-addr1 u2 msc -- c-addr2 u2 true | false ) Translate the message c-addr1 u1 with the catalog, return success
nci%( -- n ) Get the required space for a nci variable
nci-append-child( x nci -- ) Append data x as child to the children of the current node, iterator is moved to the new child
nci-child( nci -- x true | false ) Move the iterator to the first child of the current node, return the cell data x of this node
nci-children( nci -- n ) Return the number of children of the current node
nci-children?( nci -- flag ) Check if the current node has children
nci-create( nct "<spaces>name" -- ; -- nci ) Create a named iterator in the dictionary on the n-tree nct
nci-dump( nci -- ) Dump the iterator
nci-first( nci -- x true | false ) Move the iterator to the first sibling, return the cell data x from this node
nci-first?( nci -- flag ) Check if the iterator is on the first sibling
nci-free( nci -- ) Free the iterator from heap
nci-get( nci -- x true | false ) Get the cell data x from the current node
nci-init( nct nci -- ) Initialise the iterator with the n-tree nct
nci-insert-after( x nci -- ) Insert data x as sibling after the current sibling in the tree
nci-insert-before( x nci -- ) Insert data x as sibling before the current sibling in the tree
nci-last( nci -- x true | false ) Move the iterator to the last sibling, return the cell data x from this node
nci-last?( nci -- flag ) Check if the iterator is on the last sibling
nci-new( nct -- nci ) Create an iterator on the heap on the n-tree nct
nci-next( nci -- x true | false ) Move the iterator to the next sibling, return the cell data x from this node
nci-parent( nci -- x true | false ) Move the iterator to the parent of the current node, return the cell data x from this node
nci-prepend-child( x nci -- ) Prepend data x as child to the children of the current node, iterator is moved to the new child
nci-prev( nci -- x true | false ) Move the iterator to the previous sibling, return the cell data x from this node
nci-remove( nci -- x true | false ) Remove the current sibling without children from the tree, move the iterator to the next, previous or parent node, return the cell data x of the removed node
nci-root( nci -- x true | false ) Move the iterator to the root of the tree, return the cell data x from this node
nci-root?( nci -- flag ) Check if the current node is the root node
ncn%( -- n ) Get the required space for a ncn node
ncn-cell!( x ncn -- ) Set the cell data x in the node
ncn-cell@( ncn -- x ) Get the cell data from the node
ncn-dump( ncn -- ) Dump the node
ncn-free( ncn -- ) Free the node from the heap
ncn-init( x ncn -- ) Initialise the node with data x
ncn-new( x -- ncn ) Create a new node on the heap with data x
nct%( -- n ) Get the required space for a nct variable
nct-(free)( nct -- ) Free the nodes in the tree
nct-clear( nct -- ) Delete all nodes from the tree
nct-count( x nct -- u ) Count the number of the occurrences of the cell data x in the tree
nct-create( "<spaces>name" -- ; -- nct ) Create a named n-tree in the dictionary
nct-dump( nct -- ) Dump the tree
nct-empty?( nct -- flag ) Check for empty tree
nct-execute( i*x xt nct -- j*x ) Execute xt for every node in tree
nct-execute?( i*x xt nct -- j*x flag ) Execute xt for every node in the tree until xt returns true
nct-free( nct -- ) Free the tree from the heap
nct-has?( x nct -- flag ) Check if the cell data x is present in the tree
nct-init( nct -- ) Initialise the tree
nct-length@( nct -- u ) Get the number of nodes in the tree
nct-new( -- nct ) Create a new n-tree on the heap
nfe%( -- n ) Get the required space for a nfe expression
nfe+free-expression( nfe -- ) Free all states in the [sub]expression [recursive]
nfe-(free)( nfe -- ) Free the internal, private variables from the heap
nfe-alternation( nfs1 nfs2 nfs3 nfs4 nfe -- nfs5 nfs6 ) Make an alternation [|] of two expressions, return the new outs nfs5 and start nfs6
nfe-clear( nfe -- ) Clear the expression
nfe-close( nfs1 nfs2 nfe -- nfs3 ) Close the expression by adding the match state, return the start nfs3
nfe-concat( nfs1 nfs2 nfs3 nfs4 nfe -- nfs5 nfs6 ) Concat the two expressions, return the outs nfs5 and start nfs6
nfe-create( "<spaces>name" -- ; -- nfe ) Create a named expression in the dictionary
nfe-dump( nfe -- ) Dump the expression
nfe-expression@( nfe -- a-addr ) Get the list of states in the expression or nil
nfe-free( nfe -- ) Free the expression from the heap
nfe-init( nfe -- ) Initialise the expression
nfe-level+@( nfe -- n ) Increment and return the paren level
nfe-match?( c-addr u flag nfe -- flag ) Match a string c-addr u, with the flag indicating case insensitive match, return the match result
nfe-new( -- nfe ) Create a new expression on the heap
nfe-one-or-more( nfs1 nfs2 nfe -- nfs3 nfs4 ) Repeat the expression one or more [+] times, return the new outs nfs3 and start nfs4
nfe-paren( nfs1 nfs2 n nfe -- nfs3 nfs4 ) Paren the expression with level n, return the new outs nf3 and start nfs4
nfe-parens@( nfe -- n ) Get the number of parens in the expression
nfe-result( n1 nfe -- n2 n3 ) Get the match result of the n1th grouping, return match start n3 and end n2
nfe-search( c-addr u flag nfe -- n ) Search in the string c-addr u for a match, with the flag indicating case insensitive match, return the first offset for a match, or -1 for no match
nfe-single( x n nfe -- nfs1 nfs2 ) Start an expression, nfs2 nfs1, with a single new state nfs1 with data x and type n
nfe-states@( nfe -- n ) Get the number of states in the expression
nfe-visit++( nfe -- n ) Increment the visit number in the expression, return the visit number
nfe-visit@( nfe -- n ) Get the current visit number
nfe-zero-or-more( nfs1 nfs2 nfe -- nfs3 nfs4 ) Repeat the expression zero or more [*] times, return the new outs nfs3 and start nfs4
nfe-zero-or-one( nfs1 nfs2 nfe -- nfs3 nfs4 ) Repeat the expression one or zero [?] times, return the new start outs nfs3 and start nfs4
nfs%( -- n ) Get the required space for a nfs state
nfs-data@( nfs -- x ) Get the optional data of the state
nfs-dump( nfs -- ) Dump the nfs state
nfs-free( nfs -- ) Free the state from the heap
nfs-id@( nfs -- n ) Get the id of the state
nfs-init( x n1 n2 nfs -- ) Initialise the nfs state with data x, type n1 and id n2
nfs-new( x n1 n2 -- nfs ) Create a new nfs state on the heap with data x, type n1 and id n2
nfs-out1!( nfs1 nfs2 -- ) Set out1 in the nfs2 state to the nfs1 state
nfs-out1@( nfs1 -- nfs2 ) Get the out1 state of the nfs1 state
nfs-out2!( nfs1 nfs2 -- ) Set out2 in the nfs2 state to the nfs1 state
nfs-out2@( nfs1 -- nfs2 ) Get the out2 nfs state of nfs1 state
nfs-type@( nfs -- n ) Get the type of the state
nfs-visit!( n nfs -- ) Set the visit number [0>=]
nfs-visit@( nfs -- n ) Get the visit number
nfs.any( -- n ) State type any, no data
nfs.char( -- n ) State type char, data = char
nfs.class( -- n ) State type class, data = chs
nfs.lparen( -- n ) State type left paren, data = paren level
nfs.match( -- n ) State type match, no data
nfs.rparen( -- n ) State type right paren, data = paren level
nfs.split( -- n ) State type split, no data
nil!( a-addr -- ) Set address to nil
nil<>( addr -- flag ) Check for unequal to nil
nil<>?( addr -- false | addr true ) If addr is nil, then return false, else return address with true
nil=( addr -- flag ) Check for nil
nni%( -- n ) Get the required space for a nni variable
nni-append-child( nnn nni -- ) Append a child to the children of the current node, iterator is moved to the new child
nni-child( nni -- nnn | nil ) Move the iterator to the first child of the current node, return this node
nni-children( nni -- n ) Return the number of children of the current node
nni-children?( nni -- flag ) Check if the current node has children
nni-create( nnt "<spaces>name" -- ; -- nni ) Create a named iterator in the dictionary on the n-tree nnt
nni-dump( nni -- ) Dump the iterator
nni-first( nni -- nnn ) Move the iterator to the first sibling, return this node
nni-first?( nni -- flag ) Check if the iterator is on the first sibling
nni-free( nni -- ) Free the iterator from the heap
nni-get( nni -- nnn | nil ) Get the current node
nni-init( nnt nni -- ) Initialise the iterator with the n-tree nnt
nni-insert-after( nnn nni -- ) Insert a sibling after the current sibling in the tree
nni-insert-before( nnn nni -- ) Insert a sibling before the current sibling in the tree
nni-last( nni -- nnn ) Move the iterator to the last sibling, return this node
nni-last?( nni -- flag ) Check if the iterator is on the last sibling
nni-new( nnt -- nni ) Create an iterator on the heap on the n-tree nnt
nni-next( nni -- nnn | nil ) Move the iterator to the next sibling, return this node
nni-parent( nni -- nnn | nil ) Move the iterator to the parent of the current node, return this node
nni-prepend-child( nnn nni -- ) Prepend a child to the children of the current node, iterator is moved to the new child
nni-prev( nni -- nnn | nil ) Move the iterator to the previous sibling
nni-remove( nni -- nnn ) Remove the current sibling without children from the tree, move the iterator to the next, previous or parent node, return the removed node
nni-root( nni -- nnn | nil ) Move the iterator to the root of the tree, return this node
nni-root?( nni -- flag ) Check if the current node is the root node
nnn%( -- n ) Get the required space for a nnn node
nnn-dump( nnn -- ) Dump the node
nnn-free( nnn -- ) Free the node from the heap
nnn-init( nnn -- ) Initialise the node
nnn-new( -- nnn ) Create a new node on the heap
nnn-parent!( nnn1 nnn2 -- ) Set for node nnn2 the parent to nnn1
nnn-parent@( nnn1 -- nnn2 ) Get from node nnn1 the parent node
nnt%( -- n ) Get the required space for a nnt variable
nnt-(free)( xt nnt -- ) Free all nodes in the tree with xt
nnt-create( "<spaces>name" -- ; -- nnt ) Create a named n-tree in the dictionary
nnt-dump( nnt -- ) Dump the tree
nnt-empty?( nnt -- flag ) Check for an empty tree
nnt-execute( i*x xt nnt -- j*x ) Execute xt for every node in tree
nnt-execute?( i*x xt nnt -- j*x flag ) Execute xt for every node in the tree until xt returns true
nnt-free( nnt -- ) Free the tree from the heap
nnt-init( nnt -- ) Initialise the n-tree
nnt-length@( nnt -- u ) Get the number of nodes in the tree
nnt-new( -- nnt ) Create a new n-tree on the heap
nnt-root@( nnt -- nnn | nil ) Get the root of the tree
parse-esc( c-addr1 u1 c-addr2 -- c-addr3 u3 ) Parse the escaped character in string c-addr1 u1, store the result in string c-addr2 and return the remaining string c-addr3 u3
parse\"( "ccc<quote>" -- c-addr u ) Parse the input stream for a escaped string
r'@( R: x1 x2 -- x1 x2; -- x1 ) Fetch the second cell on the return stack
rdg%( -- n ) Get the required space for a rdg variable
rdg-beta( F: r1 r2 -- r3 ; rdg -- ) Generate a random number with a beta distribution with alpha r1 [>0] and beta r2 [>0], alpha*beta = mean, alpha*beta^2 = variance
rdg-binomial( F: r -- ; u1 rdg -- u2 ) Generate a random number with a binomial distribution with probability r [0,1] and trails u1 [>=0]
rdg-create( x xt "<spaces>name" -- ; -- rdg ) Create a named random generator in the dictionary with the random generator xt and its data x
rdg-exponential( F: r1 -- r2 ; rdg -- ) Generate a random number with an exponential distribution with mu or mean r1 [>0]
rdg-free( rdg -- ) Free the random generator from the heap
rdg-gamma( F: r1 r2 -- r3 ; rdg -- ) Generate a random number with a gamma distribution with alpha r1 [>0] and beta r2 [>0], alpha*beta = mean, alpha*beta^2 = variance
rdg-init( x xt rdg -- ) Initialise the generator with the random generator xt and its data x
rdg-new( x xt -- rdg ) Create a new random generator on the heap with the random generator xt and its data x
rdg-normal( F: r1 r2 -- r3 ; rdg -- ) Generate a random number with a normal or Gaussian distribution with mu or mean r1 and sigma or standard deviation r2
rdg-pareto( F: r1 r2 -- r3 ; rdg -- ) Generate a random number with a Pareto distribution with alpha r1 [>0] the scale parameter and r2 [>0] the shape parameter
rdg-poisson( F: r -- ; rdg -- u ) Generate a random number with a Poisson distribution with mean r [>=0]
rdg-uniform( F: r1 r2 -- r3 ; rdg -- ) Generate a random number with a uniform distribution in the range of [r1,r2>
rdg-weibull( F: r1 r2 -- r3 ; rdg -- ) Generate a random number with a Weibull distribution with alpha r1 [>0] the scale parameter and beta r2 [>0] the shape parameter
rgx%( -- n ) Get the required space for a rgx variable
rgx-cmatch?( c-addr u rgx -- flag ) Match case-sensitive a string with the regular expression, return match result
rgx-compile( c-addr u rgx -- true | n false ) Compile a pattern as regular expression, return success and optional the error offset n
rgx-create( "<spaces>name" -- ; -- rgx ) Create a named regular expression in the dictionary
rgx-csearch( c-addr u rgx -- n ) Search case-sensitive in a string for the first match of the regular expression, return offset in string, or -1 for not found
rgx-dump( rgx -- ) Dump the regular expression
rgx-free( rgx -- ) Free the regular expression from the heap
rgx-imatch?( c-addr u rgx -- flag ) Match case-insensitive a string with the regular expression, return match result
rgx-init( rgx -- ) Initialise the regular expression
rgx-isearch( c-addr u rgx -- n:index ) Search case-insensitive in a string for the first match of the regular expression, return offset in string, or -1 if not found
rgx-new( -- rgx ) Create a new regular expression on the heap
rgx-result( n rgx -- n1 n2 ) Get the match result of the nth grouping, return match start n2 and end n1
rng%( -- n ) Get the required space for a rng variable
rng-create( u "<spaces>name" -- ; -- rng ) Create a named random generator in the dictionary with seed u
rng-dump( rng -- ) Dump the random generator
rng-free( rng -- ) Free the random generator from the heap
rng-init( u rng -- ) Initialise the generator with the seed u
rng-new( u -- rng ) Create a new random generator on the heap with seed u
rng-next-float( rng -- r ) Calculate the next pseudo random float number, range [0,1>
rng-next-number( rng -- n ) Calculate the next pseudo random number, 32 bit
rng-seed( u rng -- ) Initialise the generator with the seed u
rroll( u1 u2 -- u3 ) Rotate u1 u2 bits to the right
s\"( "ccc<quote>" -- c-addr u ) Create a string with escaped characters
scf"( "ccc<quote>" c-addr u -- i*x j*r n ) Scan the source string c-addr1 u1 with the specifier string c-addr2 u2, resulting in n arguments i*x and j*r
scf+scan( c-addr1 u1 c-addr2 u2  -- i*x j*r n ) Scan the source string c-addr1 u1 with specifier string c-addr2 u2, resulting in n arguments i*x j*r
sci%( -- n ) Get the required space for a sci variable
sci-create( scl "<spaces>name" -- ; -- sci ) Create a named iterator in the dictionary on the scl list
sci-dump( sci -- ) Dump the iterator
sci-first( sci -- x true | false ) Move the iterator to the first node, return the cell data x from this node
sci-first?( sci -- flag ) Check if the iterator is on the first node
sci-free( sci -- ) Free the iterator from the heap
sci-get( sci -- x true | false ) Get the cell data x from the current node
sci-init( scl sci -- ) Initialise the iterator with a scl list
sci-insert-after( x sci -- ) Insert the cell data x after the current node
sci-last?( sci -- flag ) Check if the iterator is on the last node
sci-move( x sci -- flag ) Move the iterator to the next node with the cell data x
sci-new( scl -- sci ) Create an iterator on the heap on the scl list
sci-next( sci -- x true | false ) Move the iterator to the next node, return the cell data x from this node
sci-set( x sci -- ) Set the cell data x for the current node
scl%( -- n ) Get the required space for a scl variable
scl-(free)( scl -- ) Free the nodes from the heap
scl-append( x scl -- ) Append the cell data x in the list
scl-clear( scl -- ) Delete all nodes from the list
scl-compare!( xt scl -- ) Set the compare execution token for sorting the list
scl-compare@( scl -- xt ) Get the compare execution token for sorting the list
scl-count( x scl -- u ) Count the number of occurrences of the cell data x in the list
scl-create( "<spaces>name" -- ; -- scl ) Create a named scl list in the dictionary
scl-delete( n scl -- x ) Delete the nth node from the list, return the cell data from the deleted node
scl-dump( scl -- ) Dump the list
scl-empty?( scl -- flag ) Check for an empty list
scl-execute( i*x xt scl -- j*x ) Execute xt for every cell data in list
scl-find( x scl -- n ) Find the first index for cell data x in the list, -1 for not found
scl-free( scl -- ) Free the list from the heap
scl-get( n scl -- x ) Get the cell data x from the nth node in the list
scl-has?( x scl -- flag ) Check if the cell data x is present in the list
scl-index?( n scl -- flag ) Check if the index n is valid for the list
scl-init( scl -- ) Initialise the scl list
scl-insert( x n scl -- ) Insert cell data x at the nth node in the list
scl-insert-sorted( x scl -- ) Insert the cell data x sorted in the list
scl-length@( scl -- u ) Get the number of nodes in the list
scl-new( -- scl ) Create a new scl list on the heap
scl-prepend( x scl -- ) Prepend the cell data x in the list
scl-remove( x scl -- flag ) Remove the first occurrence of the cell data x from the list, return success
scl-reverse( scl -- ) Reverse or mirror the list
scl-set( x n scl -- ) Set the cell data x in the nth node in the list
scn%( -- n ) Get the required space for a scn node
scn-cell!( x scn -- ) Set the cell data x in the node
scn-cell@( scn -- x ) Get the cell data x from the node
scn-dump( scn -- ) Dump the node
scn-free( scn -- ) Free the node from the heap
scn-init( x scn -- ) Initialise the node with cell data x
scn-new( x -- scn ) Create a new node on the heap with cell data x
sffield:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field of 1 single float, return the field address
sh1%( -- n ) Get the required space for a sha1 variable
sh1+to-string( u1 u2 u3 u4 u5 -- c-addr u ) Convert SHA-1 result to the string c-addr u, using the pictured output area
sh1-create( "<spaces>name" --  ; -- sh1 ) Create a named sha-1 variable in the dictionary
sh1-dump( sh1 -- ) Dump the sh1 variable
sh1-finish( sh1 -- u1 u2 u3 u4 u5 ) Finish the SHA-1 calculation, return the sha values
sh1-free( sh1 -- ) Free the sha-1 variable from the heap
sh1-init( sh1 -- ) Initialise the sh1
sh1-new( -- sh1 ) Create a new sha-1 variable on the heap
sh1-reset( sh1 -- ) Reset the SHA-1 state
sh1-update( c-addr u sh1 -- ) Update the SHA-1 with more data c-addr u
sh2%( -- n ) Get the required space for a sha2 variable
sh2+to-string( u1 u2 u3 u4 u5 u6 u7 u8 -- c-addr u ) Convert SHA-256 result to the string c-addr u, using the pictured output area
sh2-create( "<spaces>name" -- ; -- sh2 ) Create a named SHA-256 variable in the dictionary
sh2-dump( sh2 -- ) Dump the sh2 variable
sh2-finish( sh2 -- u1 u2 u3 u4 u5 u6 u7 u8 ) Finish the SHA-256 calculation, return the result
sh2-free( sh2 -- ) Free the SHA-256 variable from the heap
sh2-init( sh2 -- ) Initialise the sh2 variable
sh2-new( -- sh2 ) Create a new SHA-256 variable on the heap
sh2-reset( sh2 -- ) Reset the SHA-256 state
sh2-update( c-addr u sh2 -- ) Update the SHA-256 with more data c-addr u
sni%( -- n ) Get the required space for a sni variable
sni-create( snl "<spaces>name" -- ; -- sni ) Create a named iterator in the dictionary on the snl list
sni-dump( sni -- ) Dump the iterator
sni-first( sni -- snn | nil ) Move the iterator to the first node, return this node
sni-first?( sni -- flag ) Check if the iterator is on the first node
sni-free( sni -- ) Free the iterator from the heap
sni-get( sni -- snn | nil ) Get the current node
sni-init( snl sni -- ) Initialise the iterator with a snl list
sni-last?( sni -- flag ) Check if the iterator is on the last node
sni-new( snl -- sni ) Create an iterator on the snl list on the heap
sni-next( sni -- snn | nil ) Move the iterator to the next node, return this node
snl%( -- n ) Get the required space for a snl variable
snl-(free)( xt scl -- ) Free the nodes from the heap using xt
snl-append( snn snl -- ) Append the node snn to the list
snl-create( "<spaces>name" -- ; -- snl ) Create a named snl list in the dictionary
snl-delete( n snl -- snn ) Delete the nth node from the list, return the deleted node
snl-dequeue( snl -- snn | nil ) Dequeue the node at the end of the queue [= start of the list], return this node
snl-dump( snl -- ) Dump the list
snl-empty?( snl -- flag ) Check for an empty list
snl-enqueue( snn snl -- ) Enqueue the node snn at the start of the queue [=end of the list]
snl-execute( i*x xt snl -- j*x ) Execute xt for every node in list
snl-execute?( i*x xt snl -- j*x flag ) Execute xt for every node in the list until xt returns true
snl-first@( snl -- snn | nil ) Get the first node from the list
snl-free( snl -- ) Free the list from the heap
snl-get( n snl -- snn ) Get the nth node from the list
snl-index?( n snl -- flag ) Check if the index n is valid in the list
snl-init( snl -- ) Initialise the snl list
snl-insert( snn n snl -- ) Insert a node before the nth node in the list
snl-insert-after( snn1 snn2 snl -- ) Insert the node snn1 after the reference node snn2 in the list
snl-last@( snl -- snn | nil ) Get the last node from the list
snl-length@( snl -- u ) Get the number of nodes in the list
snl-new( -- snl ) Create a new snl list on the heap
snl-pop( snl -- snn | nil ) Pop the node at the top of the stack [= start of the list], return the popped node
snl-prepend( snn snl -- ) Prepend the node snn in the list
snl-push( snn snl -- ) Push the node snn at the top of the stack [= start of the list]
snl-remove-after( snn1 snl -- snn2 | nil ) Remove the node after the reference node snn1 from the list, return the removed node
snl-remove-first( snl -- snn | nil ) Remove the first node from the list, return the removed node
snl-reverse( snl -- ) Reverse or mirror the list
snl-tos( snl -- snn | nil ) Get the node at the top of the stack [= start of the list], return this node
snn%( - n ) Get the required space for a snn node
snn-dump( snn -- ) Dump the single list node
snn-free( snn -- ) Free the node from the heap
snn-init( snn -- ) Initialise the node
snn-new( -- snn ) Create a new node on the heap
snn-next!( snn1 snn2 -- ) Set for the node snn1 the next node to snn2
snn-next@( snn1 -- snn2 ) Get the next node snn2 from the node snn1
spf"( "ccc<quote>" i*x j*r str -- ) Convert the arguments i*x with the format string and set the result in str
spf-append( i*x j*r c-addr u str -- k*x l*r ) Convert the arguments i*x with the format string c-addr u and append the result to str
spf-set( i*x j*r c-addr u str -- ) Convert the arguments i*x with the format string c-addr u and set the result in str
str%( -- n ) Get the required space for a str variable
str+columns( c-addr u n -- c-addrn un ... c-addr1 u1 n ) Split the string c-addr u in n substrings, u width wide, skipping leading spaces [recursive]
str+extra!( u -- ) Set the initial extra space allocated during resizing of the string
str+extra@( -- u ) Get the initial extra space allocated during resizing of the string
str+strip( c-addr1 u1 -- c-addr2 u2 ) Strip leading and trailing spaces from string c-addr1 u1
str+strip-leading( c-addr1 u1 -- c-addr2 u2 ) Strip leading whitespace in the string c-addr1 u1
str+strip-trailing( c-addr u1 -- c-addr u2 ) Strip trailing whitespace in the string c-addr u1
str-(free)( str -- ) Free the string data from the heap
str-align-left( u str -- ) Align left the string in width u
str-align-right( u str -- ) Align right the string in width u
str-append-char( char str -- ) Append a character at the end of the string
str-append-chars( char u str -- ) Append u chars in the string
str-append-string( c-addr u str -- ) Append the string c-addr u to the string
str-bounds( str -- c-addr+u c-addr ) Get the bounds of the string
str-cap-words( str -- ) Capitalize all words in the string
str-capatilize( str -- ) Capitalize the first word in the string
str-ccompare( c-addr u str -- n ) Compare case-sensitive the string c-addr u with the string, return the result [-1,0,1]
str-center( u str -- ) Center the string in width u
str-clear( str -- ) Clear the string
str-count( c-addr u str -- u ) Count the number of occurrences of the string c-addr u in the string
str-create( "<spaces>name" -- ; -- str ) Create a named empty string in the dictionary
str-data@( str -- c-addr ) Get the start of the string
str-delete( u n str -- ) Delete a substring starting at index n with length u from the string
str-delete-char( n str -- ) Delete the character on the nth position in the string
str-dequeue-char( char str -- ) Get the character at the end of the string
str-dump( str -- ) Dump the string
str-empty?( str -- flag ) Check for an empty string
str-enqueue-char( char str -- ) Place a character at the start of the string
str-execute( i*x xt str -- j*x ) Execute the xt token for every character in the string
str-expand-tabs( u str -- ) Expand the tabs to u spaces in the string
str-extra!( u str -- ) Set the extra space allocated during resizing of the string
str-extra@( str -- u ) Get the extra space allocated during resizing of the string
str-find( c-addr u n1 str -- n2 ) Find the first occurrence of the string c-addr u starting from index n1 in the string, return -1 if not found
str-free( str -- ) Free the string from the heap
str-get( str -- c-addr u ) Get the string in the string
str-get-char( n str -- char ) Get the character from the nth position in the string
str-get-substring( u n str -- c-addr u ) Get a substring starting from index n,  u characters long
str-get-zstring( str -- c-addr ) Get the string as zero terminated string
str-icompare( c-addr u str -- n ) Compare case-insensitive the string c-addr u with the string, return the result [-1,0,1]
str-index?( n str -- flag ) Check if the index n is valid in the string
str-init( str -- ) Initialise to an empty string
str-insert-char( char n str -- ) Insert the character on the nth position in the string
str-insert-chars( char u n str -- ) Insert u chars in the string at index n
str-insert-string( c-addr u n str -- ) Insert the string c-addr in the string at index n
str-length!( u str -- ) Set the length of the string
str-length@( str -- u ) Get the length of the string
str-lower( str -- ) Convert the string to lower case
str-new( -- str ) Create a new empty string on the heap
str-pop-char( str -- char ) Pop a character from the end of the string
str-prepend-char( char str -- ) Prepend a character at the start of the string
str-prepend-chars( char u str -- ) Prepend u chars in the string
str-prepend-string( c-addr u str -- ) Prepend the string c-addr u to the string
str-push-char( char str -- ) Push a character at the end of the string
str-replace( c-addr1 u1 c-addr2 u2 str -- ) Replace all occurences of the string c-addr2 u2 with the string c-addr1 u1 in the string
str-set( c-addr u str -- ) Set the string c-addr u in the string
str-set-char( char n str -- ) Set the character on the nth position in the string
str-set-zstring( c-addr str -- ) Set a zero terminated string in the string
str-size!( u str -- ) Insure the size u of the string
str-strip( str -- ) Strip leading and trailing spaces in the string
str-strip-leading( str -- ) Strip leading spaces in the string
str-strip-trailing( str -- ) Strip trailing spaces in the string
str-upper( str -- ) Convert the string to upper case
str^ccompare( str1 str2 -- n ) Compare case-sensitive the string str1 and str2, return the result [-1,0,1]
str^icompare( str1 str2 -- n ) Compare case-insensitive the strings str1 and str, return the result [-1,0,1]
tis%( -- n ) Get the required space for a tis variable
tis-(free)( tis -- ) Free the internal, private variables from the heap
tis-cmatch-char( char tis -- flag ) Match case-sensitive a character
tis-cmatch-chars( c-addr u tis -- false | char true ) Match one of the characters in the string case-sensitive
tis-cmatch-string( c-addr u tis -- flag ) Match case-sensitive a string
tis-create( "<spaces>name" -- ; -- tis ) Create a named input stream in the dictionary
tis-dump( tis -- ) Dump the text input stream
tis-eof?( tis -- flag ) Check if the end of the stream is reached
tis-fetch-char( tis -- false | char true ) Fetch the next character from the stream
tis-fetch-chars( n tis -- 0 | addr u ) Fetch maximum of n next characters from the stream
tis-free( tis -- ) Free the input stream from the heap
tis-get( tis -- 0 | addr u ) Get the remaining characters from the stream, stream pointer is not changed
tis-imatch-char( char tis -- flag ) Match case-insensitive a character
tis-imatch-string( c-addr u tis -- flag ) Match case-insensitive a string
tis-init( tis -- ) Initialise the empty input stream
tis-iscan-string( c-addr1 n1 tis -- false | c-addr2 u2 true ) Read characters till the string c-addr1 n1 [case insensitive]
tis-match-set( chs tis - false | char true ) Match one of the characters in the set
tis-new( -- tis ) Create a new input stream on the heap
tis-next-char( tis -- ) Move the stream pointer one character after fetch-char
tis-next-chars( n tis -- ) Move the stream pointer n characters after fetch-chars
tis-pntr!( n tis -- flag ) Set the stream pointer from start {>=0} or from end {<0}
tis-pntr+!( n tis -- flag ) Add the offset u to the stream pointer
tis-pntr@( tis -- u ) Get the stream pointer
tis-read-all( tis -- 0 | c-addr u ) Read all remaining characters from the stream
tis-read-char( tis -- false | char true ) Read character from the stream
tis-read-double( tis -- false | d true ) Read a double value in the current base from the stream
tis-read-line( tis -- 0 | c-addr u ) Read characters till cr and/or lf
tis-read-more( tis -- flag ) Read more data from the reader
tis-read-number( tis -- false | n true ) Read a cell number in the current base from the stream
tis-read-string( n tis -- 0 | c-addr u ) Read n characters from the stream
tis-reduce( tis -- ) Reduce the stream size
tis-reset( tis -- ) Reset the input stream for reading from string
tis-scan-char( char tis -- false | c-addr u true ) Read characters till the char
tis-scan-chars( c-addr1 n1 tis -- false | c-addr2 u2 char true ) Read characters till one of characters in c-addr1 u1
tis-scan-set( chs tis - false | c-addr u char true ) Read characters till one of the characters in the set chs
tis-scan-string( c-addr1 n2 tis -- false | c-addr1 u2 true ) Read characters till the string c-addr1 n1
tis-set( c-addr u tis -- ) Initialise the stream for reading from a string
tis-set-reader( x xt tis -- ) Initialise the stream for reading using the reader callback xt and its data x
tis-skip-spaces( tis -- n ) Skip whitespace in the stream, return the number of skipped whitespace characters
tmr%( - n ) Get the required space for the timer variable
tmr-create( u "<spaces>name" -- ; -- tmr ) Create a named timer variable in the dictionary with timeout u
tmr-dump( tmr -- ) Dump the tmr state
tmr-expired?( tmr -- flag ) Check if the timer is expired, if so the timer is restarted
tmr-free( tmr -- ) Free the timer from the heap
tmr-init( u tmr -- ) Initialise the timer with timeout u
tmr-new( u -- tmr ) Create a new timer variable on the heap with timeout u
tmr-restart( tmr -- ) Restart the timer with the current timeout value
tmr-start( u tmr -- ) Start the timer with a timeout value u
tmr-timeout@( tmr -- u ) Get the timeout value from the timer
tmr-timer@( tmr -- u ) Get the running time u from the timer in ms, after last [re]start, expired? or wait
tmr-wait( tmr -- ) Wait till the timer expires and restart the timer
tos%( -- n ) Get the required space for a tos variable
tos-(free)( tos -- ) Free the tos data from the heap
tos-align( char u1 u2 tos -- ) Align the previous written data with padding character char, u1 trailing chars and u2 leading chars
tos-align-left( char u tos -- ) Align the previous written data to the left, using padding character char with width u
tos-align-right( char u tos -- ) Align the previous written data to the right, using padding character char with width u
tos-center( char u tos -- ) Center the previous written data, using padding character char with width u
tos-create( "<spaces>name" -- ; -- tos ) Create a named output stream in the dictionary
tos-dump( tos -- ) Dump the text output stream
tos-flush( tos -- ) Flush the contents of the stream to the writer
tos-free( tos -- ) Free the output stream from the heap
tos-init( tos -- ) Initialise the empty output stream
tos-msc!( msc tos -- ) Set the message catalog for the output stream
tos-msc@( tos -- msc | nil ) Get the message catalog for the output stream
tos-new( -- tos ) Create a new output stream on the heap
tos-pntr!( n tos -- flag ) Set the alignment pointer from start [n>=0] or from end [n<0], return success
tos-pntr+!( n tos -- flag ) Add the offset n to the alignment pointer, return success
tos-pntr@( tos -- u ) Get the current alignment start pointer
tos-rewrite( tos -- ) Rewrite the output stream
tos-set-writer( x xt tos -- ) Use the stream for writing using the writer callback xt and its data x
tos-write-char( char tos -- ) Write character to the stream
tos-write-chars( char u tos -- ) Write u chars to the stream
tos-write-double( d tos -- ) Write the double d in the current base to the stream
tos-write-fixed-point( r tos -- ) Write the float r to the stream in fixed-point notation: [-]digits.digits0, using PAD and PRECISION
tos-write-float( r tos -- ) Write the float r to the stream in notation: [-]0.digitsE[-]digits, using PAD and PRECISION
tos-write-line( tos -- ) Write end-of-line from config to the stream, not align able
tos-write-number( n tos -- ) Write the number n in the current base to the stream
tos-write-string( c-addr u tos -- ) Write the string c-addr u to the stream, using the message catalog if present
trace"( "ccc<quote>" -- ) Log a trace message
trm+activate-console( u -- ) Bring the console to the front
trm+clear-all-leds( -- ) Clear all LEDs
trm+clear-all-tab-stops( -- ) Clear all tab stops
trm+clear-tab-stop( -- ) Clear tab stop at current column
trm+delete-chars( u -- ) Delete n characters on the current line
trm+delete-lines( u -- ) Delete u lines
trm+erase-chars( u -- ) Erase u characters on the current line
trm+erase-display( -- ) Erase the whole display
trm+erase-display-down( -- ) Erase display from cursor to end
trm+erase-display-up( -- ) Erase from start display to cursor
trm+erase-end-of-line( -- ) Erase the line from cursor to end of line
trm+erase-line( -- ) Erase the whole line
trm+erase-start-of-line( -- ) Erase the line from start line to cursor
trm+insert-lines( u -- ) Insert u blank lines
trm+insert-spaces( u -- ) Insert u spaces
trm+move-cursor( u1 u2 -- ) Move cursor to column and row with x u1 and y u2
trm+move-cursor-down( u -- ) Move cursor down u rows
trm+move-cursor-left( u -- ) Move cursor left u columns
trm+move-cursor-right( u -- ) Move cursor right u columns
trm+move-cursor-up( u -- ) Move cursor up u rows
trm+reset( -- ) Reset the terminal
trm+restore-current-state( -- ) Restore the current state: cursor, attributes and character sets
trm+restore-cursor( -- ) Restore cursor location
trm+save-current-state( -- ) Save the current state: cursor, attributes and character sets
trm+save-cursor( -- ) Save cursor location
trm+scroll-down( -- ) Scroll the display down
trm+scroll-up( -- ) Scroll the display up
trm+select-alternate-font( -- ) Select the alternate character set
trm+select-default( -- ) Select the default character set ISO8859-1
trm+select-default-font( -- ) Select the default character set
trm+select-graphics-font2( -- ) Select the vt100 graphics font for the alternate font
trm+select-UTF-8( -- ) Select the UTF-8 character set
trm+set-attributes( u1 .. un n -- ) Set n attributes
trm+set-caps-led( -- ) Set the caps lock LED
trm+set-default-attributes( -- ) Set the current attributes the default attributes
trm+set-num-led( -- ) Set the num lock LED
trm+set-screen-blank-timeout( u -- ) Set the screen blank timeout in minutes
trm+set-scroll-led( -- ) Set the scroll lock LED
trm+set-scroll-region( u1 u2 -- ) Set the scroll region rows with top u2 and bottom u1
trm+set-tab-stop( -- ) Set tab stop at current column
trm+unblank-screen( -- ) Unblank the screen
trm.background-black( -- u ) Set black background
trm.background-blue( -- u ) Set blue background
trm.background-brown( -- u ) Set brown background
trm.background-cyan( -- u ) Set cyan background
trm.background-default( -- u ) Set default background
trm.background-green( -- u ) Set green background
trm.background-magenta( -- u ) Set magenta background
trm.background-red( -- u ) Set red background
trm.background-white( -- u ) Set white background
trm.blink-off( -- u ) Reset blink
trm.blink-on( -- u ) Set blink
trm.bold( -- u ) Set bold
trm.foreground-black( -- u ) Set black foreground
trm.foreground-blue( -- u ) Set blue foreground
trm.foreground-brown( -- u ) Set brown foreground
trm.foreground-cyan( -- u ) Set cyan foreground
trm.foreground-def-underline( -- u ) Set default foreground with underscore on
trm.foreground-default( -- u ) Set default foreground
trm.foreground-green( -- u ) Set green foreground
trm.foreground-magenta( -- u ) Set magenta foreground
trm.foreground-red( -- u ) Set red foreground
trm.foreground-white( -- u ) Set white foreground
trm.half-bright( -- u ) Set half bright
trm.normal-intensity( -- u ) Set normal intensity
trm.reset( -- u ) Reset attributes to defaults
trm.reverse-off( -- u ) Reset reverse
trm.reverse-on( -- u ) Set reverse video
trm.underline-off( -- u ) Reset underline
trm.underscore-on( -- u ) Set underscore
tst-get-result( -- u1 u2 u3 ) Get the test results, return the test time u1, the number of tests u2 and the number of errors u3
tst-reset-tests( -- ) Reset the test results
t{( -- ) Start a test
u>l( u -- l ) Convert a unsigned number to 32 bit number
u>l( u -- l ) Convert a unsigned number to 32 bit number
w!( n w-addr -- ) Store a word, 16 bit
w,( x -- ) Store 16 bits of data in the data storage
w@( w-addr -- u ) Fetch a word, 16 bit, zero extend
warning"( "ccc<quote>" -- ) Log a warning message
wfield:( structure-sys "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field for a word, 2 bytes, not aligned, return the field address
wfields:( structure-sys n "<spaces>name" -- structure-sys ; addr1 -- addr2 ) Create a structure field for n words, not aligned, return the field address
xis%( -- n ) Get the required space for a xis reader variable
xis+dump-read-parameters( i*x n -- ) Dump the various parameters of a xml token after calling xis-read &lb;see xml reader constants&rb;
xis+remove-read-parameters( i*x n -- ) Remove the various parameters of a xml token after calling xis-read &lb;see xml reader constants&rb;
xis-(free)( xis -- ) Free the internal, private variables from the heap
xis-create( "<spaces>name" -- ; -- xis ) Create a named xml reader variable in the dictionary
xis-free( xis -- ) Free the xis reader variable from the heap
xis-init( xis -- ) Initialise the xml reader variable
xis-msc!( msc xis -- ) Set the entity reference catalog for the reader
xis-msc@( xis -- msc ) Get the current entity reference catalog
xis-new( -- xis ) Create a new xml reader variable on the heap
xis-read( xis -- i*x n ) Read the next xml token n with various parameters from the source &lb;see xml reader constants&rb;
xis-set-reader( x xt xis -- ) Init the xml parser for reading using the reader callback xt with its data x
xis-set-string( c-addr u xis -- ) Init the xml parser for for reading from the string c-addr u
xis-strip!( flag xis -- ) Set the flag indicating the stripping of leading and trailing white space in normal text
xis-strip@( xis -- flag ) Return flag indicating the stripping of leading and trailing white space in normal text
xis.cdata( -- n ) CDATA section
xis.comment( -- n ) Comment
xis.done( -- n ) Done reading
xis.empty-element( -- n ) Empty element
xis.end-tag( -- n ) End tag
xis.error( -- n ) Error
xis.internal-dtd( -- n ) Internal DTD
xis.proc-instr( -- n ) Proc. instr.
xis.public-dtd( -- n ) Public DTD
xis.start-tag( -- n ) Start tag
xis.start-xml( -- n ) Start Document
xis.system-dtd( -- n ) System DTD
xis.text( -- n ) Normal text
xos-write-cdata( c-addr u tos -- ) Write a xml CDATA section
xos-write-comment( c-addr u tos -- ) Write a xml comment
xos-write-empty-element( c-addr1 u1 ... c-addr2n u2n n c-addr u tos -- ) Write the xml start and end tag c-addr u with n attributes and values c-addr* u*
xos-write-end-tag( c-addr u tos -- ) Write the xml end tag c-addr u
xos-write-internal-dtd( c-addr1 u1 c-addr2 u2 tos -- ) Write an internal document type definition with name c-addr2 u2 and markup c-addr1 u1
xos-write-proc-instr( c-addr1 u1 c-addr2n u2n n c-addr u tos -- ) Write a xml processing instruction with target c-addr u and n attributes and values c-addr* u*
xos-write-public-dtd( c-addr1 u1 c-addr2 u2 c-addr3 u3 c-addr4 u4 tos -- ) Write a public document type definition with name c-addr4 u4, markup c-addr3 u3, public-id c-addr2 u2 and system c-addr1 u1
xos-write-raw-text( c-addr u tos -- ) Write unprocessed xml text
xos-write-start-tag( c-addr1 u1 ... c-addr2n u2n n c-addr u tos -- ) Write the xml start tag c-addr u with n attributes and values c-addr* u*
xos-write-start-xml( c-addr1 u1 ... c-addr2n u2n n tos -- ) Write the start of a xml document with n attributes and values
xos-write-system-dtd( c-addr1 u1 c-addr2 u2 c-addr3 u3 tos -- ) Write a system document type definition with name c-addr3 u3, markup c-addr2 u2 and system c-addr1 u1
xos-write-text( c-addr u tos -- ) Write normal xml text c-addr u with translation to the default entity references
zif%( -- n ) Get the required space for a zif variable
zif+input-size!( u -- ) Set the default input buffer size &lb;default 2kb, min. 1kb&rb;
zif+input-size@( -- u ) Get the default input buffer size
zif+output-size!( u -- ) Set the default output buffer size &lb;default 64kb+4kb, min. 64kb+4kb&rb;
zif+output-size@( -- u ) Get the default output buffer size
zif-(free)( zif -- ) Free the internal, private variables from the heap
zif-close-file( zif -- ior ) Close the file
zif-create( "<spaces>name" -- ; -- zif ) Create a named gzip file reader variable in the dictionary
zif-dump( zif -- ) Dump the variable
zif-free( zif -- ) Free the variable from the heap
zif-gzf@( zif -- gzf ) Get the reference to the gzip file header info after zif-read-header
zif-init( zif -- ) Initialise the gzip file reader variable
zif-new( -- zif ) Create a new gzip file reader variable on the heap
zif-open-file( c-addr u zif -- ior ) Open an existing gzip file for reading with name c-addr u
zif-read-file( c-addr1 u1 zif -- u2 ior ) Read/decompress maximum u1 bytes from the file and store those at c-addr1, return the actual read bytes
zif-read-header( zif -- ior ) Read the &lb;next&rb; header from the gzip file
}t( i*x j*r -- ) Check for stack overflow
